[toc]
***

# 数据结构
1. 数据结构的构成：
   +  逻辑结构：元素之间的相互关系。
		* 线性结构：除头尾节点，每一个节点有仅有一个前驱和后继。
		* 树形结构：除根节点外，每一个节点仅有一个前驱可有多个后继。
		* 图（复杂结构）：前驱和后继数目无要求。
   +  存储结构：逻辑结构在计算机中的存储方式。
		* 顺序结构：逻辑上连续的物理上也连续。
		* 连接结构：逻辑上连续的物理上可能连续。
		* 散列表示：地址转化法，如字典。
		* 索引表示：建立辅助的索引结构。
   +  操作：方法
2.	栈区：自动申请，自动释放，编译器管理，空间有限（KB-几MB）。
3.	堆区：手动申请，手动释放，自己管理，空间大。
4.	时间复杂度：当数量N趋于无穷大时，时间与N的比例关系
3.1.O(n)线性相关 O(n*n)两层for循环成平方关系 O(n*log2N)第一层for每次i递增2第二层递增1。	
5.	空间复杂度：当数量N趋于无穷大时，花费的额外的空间与N的比例关系。
+  时间复杂度与空间复杂度是相互影响的，可牺牲一个成全另一个。
+ 线性与非线性结构：
  - 线性：元素之间存在一一对应关系。常见的非线性结构有：二（N）维数组，广义表，数，图。
  

## 线性表
1.	由有限个具有相同性质的元素组成的有序序列，含大量记录的线性表保存在外存上称为文件。
2.	线性表的
+	数组实现：
```
typedef struct 
{
	 int a[100];//存放线性表的数组 
	 int last;//线性表的长度 
}seqlist
```
2.2链表实现：用链表存储数据。（头插法和尾插法）		.
### **栈（stack）**：
 + (递归的实现用栈保存每次数据的地址) 
```
 typedef struct{
	ElemType date[];//数据域，ElemType为不确定的数据类型，使用时用typedef从定义即可 ，eg：typedef int ElemType,即可将结构体中的类型定义为int型。
	int top;//用top做栈指针 
}stack; 
```

+  顺序栈（利用数组存储数据，压入，弹出）：
+ 入栈：先检查栈不满则入栈，否则输出-1。
+ 链栈：需要多个栈时（用头插法建立链表，将新节点的地址保存在top栈指针中）
+ 可以用链表实现，每读入一个数据申请一个节点，将新的节点插入到链表的头部，变成第一个节点。
### 递归转换：
+ 迭代：只有一层的递归易转换为迭代（如求n！先求1！再迭代到2！直到n！）
+  尾递归消除：尾递归是递归调用语句是最后函数最后一句，消除方法用一个变量保存上一次上一次的值。
+ 用栈消除递归
+ Eg：void Outputl(LinkedList L)//顺序输出单链表结点数据的递归算法
```
{
if(L) {printf(L->data);//输出结点的值、 
Output1(L->next);//尾递归调用

}//0utput1 
Eg：void Output2(LinkedList L)//顺序输出单链表结点数据的非递归算法
{
p=L;//设局部变量p=L
Lbl;//在第一个可执行语句前设标号
if(p){printf(p->data);//输出结点的值
p=p->next;//修改变量值
goto Lb1;//转到第一个可执行语句}
```
 
### 队列
1.	定义：只能在一端插入和删除，通常要两个指针分别指向队头和队尾。
2.	每加入一个元素队列都会整体下移，导致虽然不满但是已经溢出的假溢出现象，可以用循环队列解决，循环队列要设置标志表示队列是否非空。
##串（string）
1.	即字符串，类似线性表。


 

## 数组与广义表
1.	一维数组可以看做一个线性表，二维数组可以看做元素为一维数组的线性表。（多维数组可转化为一维数组，eg：a[m][n]中的a[2][3]=3*n+2*1类似为不规则进制的数转化为10进制的数）
2.	矩阵的压缩存储：
+	对称与三角矩阵：存储一半以行为主序的有序对。
+	对角矩阵：以对角线为顺序储存。
+	稀疏矩阵：三元组表（用struct定义int  row(行坐标),col（列）; ElemType e;）
+	利用三元组表可以实现快速转置与计算，交换row与col值输出即可
+	储存稀疏矩阵可以十字链表（即含有四个指针分别指向上下左右）
3.	广式表：
+	简称列表，是线性表的推广。其含有原子与子表。 

 
##链表：
+ 循环链表：从任意一个节点都可以历遍整个链表，可通过头指针==尾指针判断是否到达表尾。（通常只设尾指针即可）
+ 双向链表：单链表加入一个指向前驱的指针，可以方便元素的插入与删除。（p->p1->next可以得到p指向的下一个节点所指向的指针地址）
+ 静态链表：
```  
typedef struct{
				int date;//数据域 
				int next;//指针域 
}startline;建立数组用指针域保存下标。
```
 
## 树
1.	
2.	应用：数据的压缩，对文章中的字母按频率建立哈曼夫树，重新编码

 
## 图
 
# 算法
## 算法基础
1.	时间复杂度：数据趋于N时，所需的时间。Eg：两层for循环复杂度为N*N，一层for循环i+=2复杂度为log2 N（如二分搜索，一亿个数据仅需27次）
2.	空间复杂度：数据趋于N时，所需的时间。（有的算法需要额外的辅助空间）
 
分治法
1.	将大问题分为小问题解决后合并最终解决大问题。
+	



 
## 排序
1.	插入排序：
+	将无序序列中的一个或几个记录“插入”到有序序列中，从而增加记录的
有序序列的长度。
+	折半插入：结合了二分查找。
+	二路插入：将第一个元素作为中间mid，小于mid在左边折半插入。
2.	冒泡排序：
+	冒泡排序：通过“交换”无序序列中的相邻记录从而得到其中关键字最小或最大的记
录，并将它加入到有序序列中以增加记录的有序序列的长度。
+	快速排序：取第一个记录为中枢，小于中枢的后移大于的前移，一次后中枢将数据分为两段，两段再各自找中枢，到步长为3。
+	快速划分：用a[i] a[j]代表左右记录，与中枢比较后若左记录小，将其与中枢交换。直到i==j，可以暂存中枢结束后再将中枢放好。
3.	选择排序：从记录的无序序列中“选择”关键字最小或最大的记录，并将它加入到有
序子序列中，以增加记录的有序序列的长度。
4.	归并排序：通过“归并”两个或两个以上的有序序列，逐步增加有序序列的长度。5）分配排序：通过对无序序列中的记录进行反复的“分配”和“收集”操作，逐步使无序序列变为有序序列。
5.	表插入排序：用静态列表保存排序记录，排序过程就是改变指针值。
6.	希尔排序：分为取小于n的d将n分为m个子序对子序插入排序（分法：n1=n/d;n2=n1/d）
7.	堆排序：
+	桶排序
+	基数排序：eg：/10得到的数作为基按基分为基桶，基桶再桶排序。
8.	归并排序：
+	归并是将两个即以上的有序表合并为一个新的有序表‘
+	归并排序通常用2路归并，不断二分直到步长为2，再两两归并，四四归并….


 
## 搜索
1.	斐波那契查找：建立斐波那契树查找。
2.	二分查找（**0必须是线性储存的数据**）：注意a>b[mid]时add=mid+1;(a[mid]已经比较过)
3.	差值查找：数据差值均匀，mid=f((add+len));
4.	分块查找（索引顺序查找）：将数据分块，以每一块的首元建立索引表（辅助查找的数组）
5.	二叉查找树：
6.	散列表上的查找：建立一个关键词对应地址的函数，该函数就称为散列函数。
+	散列函数建立可能出现冲突（不同关键词得到了同一地址），一般冲突可减少不可避免故应该预设解决冲突的方法。（好的散列函数应该便于计算，冲突少，有解决冲突的方法）
+	散列函数的构造方法：
（联用下面几种方法，并将取余法作为最后一个，保证关键字在区间中）
	-	直接构造，即取关键字为散列函数值。（H(key)=a*key+b）
	-	数字分析法：取关键字中重复较少的数位为关键字。
	-	折叠法：将较长的关键字分割为数位相同的几段，相加后舍去进位得到的地址为散列地址，适用关键字长&&每一位数字分布均匀。
	-	平方取中法：将关键字平方再取中间的几位数作为关键数，因为平方后的中间几位数与所有的数都有关系》
	-	除留余数法：将关键字对合适的数（通常为小于散列函数长度的最大的质数）取余的结果作为关键字。
+	构造散列函数注意：
	-	计算散列函数所需的时间。
	-	关键字的长度。
	-	散列表的长度。
	-	关键字的分布情况。
	-	记录的查找频率 
+	散列函数冲突解决方法：
	-	开放地址法：发生冲突时在冲突位置的前后探测空位置存放，为防止冲突二次聚集，通常将步长加到足够长。
	-	链地址法：用链表保存散列地址，每有一个重复的数就保存在一个新申请的空间中并将用头插反法插入在重复地址之前。

 

## 动态规划
1.	动态规划减少了重复的计算，但是要额外的存储空间。
2.	主要用在：解决重叠子于最优子问题。
+	 重叠子问题：即在求解原问题的过程中，我们需要解决很多重复的子问题。因此，我们可以使用动态规划算法将这些子问题解决一次，然后将它们的解缓存起来，以节省时间。
+	最优子结构性质：即原问题的最优解可以通过求解子问题的最优解来获得。因此，我们可以使用动态规划算法将原问题的最优解分解为若干个子问题的最优解，然后通过这些最优解来构造原问题的最优解。
3.	常用步骤：
4. 确定状态：将问题分解为若干个子问题，并明确每个子问题中的状态是什么。
5. 定义状态转移方程：通过递推的方式，确定每个状态是如何由之前的状态转移而来的。
6. 初始化：确定初始状态的值，通常是问题中的边界条件。
7. 计算最终结果：通过状态转移方程，逐步计算得到最终的解。
4.	状态转移方程：
4.1 