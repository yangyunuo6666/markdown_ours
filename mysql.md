[toc]
***

# 易错集合与技巧
+ 检查非空：IS NOT NULL,检查不在此范围：NOT IN(BEGIN,END) 或 not between 10 and 18
+ 使用set a=a+1 where a>5**通常需要考虑是否需要后接一个where子句**
+ 单词拼写：delete、update、rollback、insert、cursor游标、fetch遍历、auto_increment、declare、restrict限制、cascade、procedure，**可以使用拼音输入让输入法给你纠错。**
+ 事务中错误、不一致问题：都回答属于脏读、脏写、不可重复读、幻读。
+ 使用聚合函数时，注意是否题目已经有需要聚合的字段，将其填入看看是否合理。
+ 关系模式冗余属性的消除：通过函数可推出的属性冗余，存在关联的属性可能存在冗余。
+ select语句中一处使用了表的别名，语句中所有位置用到此表都要使用别名。
+ 触发器创建：CREATE trigger 触发器名
  **before|after** 触发事件
  ON 表名
  FOR EACH **ROW**
  BEGIN
  触发器体
  END
+ ER图转换为关系模式时，要考虑是一对一、还是一对多、或是多对多，**联系要结合关系模式注意是否为N:M:P型联系**
+ group：分组统计，order：排序同时分组。
+ 使用属性名时需要注意是否存在重名，**需要删除数据时要考虑外键约束对删除顺序的影响。**
+ 自连接无条件时：注意是否需要在where中给出筛选条件代替连接条件的作用。
+ 说明规范化为3NF的方法：对XX表进行模式分解，消除XX对码的XX依赖+分解后的表。
+ **答题完整性：如不要回答“会”，要回答“会有产生死锁的可能”**
+ 审题注意在或不在、是或不是，表名注意一一对应。
+ **补充A、B两处的空缺并描述完整性约束：补充完后还需要说明A、B关系模式的主键和外键和可能存在的实体完整性约束**，有多个关系模式需要注明主键时需要一一指出各个关系模式对应的主键（如：学生关系模式的主键是学号，外键无）
+ 二叉树无第0层，除快速排序和堆排序不稳定其他都稳定。
+ 需要考虑需要提前多少时间才能赶到，工作日比周末需要提前1小时以上。
+ 字段名字大概率首字符都需要大写。
+ 作图题第一次卡死后，举手示意监考可帮你重新登录，后记得将图重置防止再次卡死在相同地方。
+ 作图题的关系模式作图要掌握如何用下划线标记出主键。
+ 作图题时每选择一项（如绘制一个实体）完成后都要点下空白处，使其变灰后才可继续操作，防止卡死。

# 计算机基础知识
## 硬件系统构成：主机（CPU和储存器）和外设
### CPU（运算器和控制器）
   + cpu读取数据时，发出的数据地址是主存物理地址
   + 运算器：ALU、AC、DR、PSW
      * 功能：（1）执行所有的算术运算和逻辑运算并进行逻辑测试。
      *  **算术逻辑单元(ALU)**：负责处理数据，实现对数据的算术运算和逻辑运算。
      *  **累加寄存器（AC）**：也称累加器，当算术逻辑单元ALU执行运算时，为其提供一个工作区。(3)数据缓冲寄存器(DR）：对内存进行读写操作时，用DR暂时存放由内存读写的一条指令或一个数据字。作为CPU和内存、外设之间在操作速度上的缓冲，以及数据传送的中转站。
      *  **状态条件寄存器（PSW)**：保存根据算术指令和逻辑指令运行或测试的结果建立的各种条件码的内容，主要分为状态标志和控制标志。如运算结果进位标志(C)、运算结果溢出标志(V)、运算结果为0标志(Z)、运算结果为负标志（N）、中断标志（1）、方向标志（D）等。
   + 控制器：IR、PC、AR、ID
      * 功能：决定了计算机运行过程的自动化。它不仅要保证程序的正确执行，而且要能够处理异常事件。包括：指令控制逻辑、时序控制逻辑、总线控制逻辑和中断控制逻辑等几个部分。
      * **指令寄存器（1R）**：用来暂时存放一条 (**正在执行的**)指令，由指令译码器根据指令寄存器中的内容产生各种微操作指令，控制其它部分协调工作
      * **程序计数器（PC）**：存放的是将要执行的下一条指令的地址。
      * **地址寄存器(AR）**：保存当前CPU所访问的内存单元的地址。由于内存和CPU存在操作速度上的差异，所以需要使用AR保存地址信息，直到内存读/写操作完成为止。
      * **指令译码器（ID)**：对指令中的操作码字段进行分析解释，识别该指令规定的操作，然后向操作控制器发出具体的控制信号。
   + 寄存器组：专用寄存器、通用寄存器
#### cup中断
##### 外部中断
+ I/O设备中断：当I/O设备完成一个操作后，向CPU发出中断请求。
+ 时钟中断：由时钟部件发出的周期性中断信号，实现程序并发运行和时间管理。
+ 外部事件中断：由用户通过输入设备触发的中断。
+ 其他外部事件导致的中断，如电源故障，外部复位。
##### 内部中断
+ 陷入中断：由陷入指令引发的，是程序员设计故意引发的中断。
+ 故障中断（可能别内核修复）：由错误引发的中断。（除数为0、缺页故障、运算溢出）
+ 异常中断：由致命错误引起，无法被内核程序修复，通常会导致程序终止。（如使用非法特权指令、访问无效的内存地址）
#### cup调度算法
+ **先来先服务（FCFS）**：按照请求的顺序进行处理，适用高频使用cup低I/O操作。
+ **时间片轮转（RR）**：将时间分成多个时间片，每个时间片称为一个时间轮次，每个时间轮次轮流分配给各个进程，适用于分布式系统。
+ **优先级调度（PRIORITY）**：按照进程的优先级来决定进程的执行顺序。
+ **短作业优先（SJF）**：按照作业的估计运行时间来决定作业的执行顺序。
+ **高响应比优先（HRRN）**：按照作业的响应比来决定作业的执行顺序。
+ **多级反馈队列（MLFQ）**：将时间分成多个时间片，每个时间片称为一个时间轮次，每个时间轮次轮流分配给各个进程。

### 存储器
   + 内部存储器（主存）：速度快，容量小。
   + 外部存储器（外存）：速度慢，容量大。如便盘输入/输出设备（外设）：键盘、鼠标、扫描仪、打印机等
   + 总线：同时只允许一个部件访问总线，以保证总线上的数据不冲突，但可有多个部件接收总线上的数据。
     - 内部总线（系统内线）：CPU、主存、I/O接口之间
       * **数据总线(DB)**：用来传送数据信息，是双向的。DB的宽度决定了CPU和计算机其他设备之间每次交换数据的位数。
       * **地址总线(AB)**：用于传送CPU发出的地址信息，是单向的。地址总线的宽度决定了CPU的最大寻址能力。
       * **控制总线（CB）**：用来传送控制信号、时序信号和状态信息等。CB中的每一条线的信息传送方向是单方向且确定的，但CB作为一个整体则是双向的。
       * **总线的缺点**：可能导致数据传输减慢，可能由两点间距改变。
       * ***总线的优点***：① 简化了系统结构，便于系统设计制造;
      ②大大减少了连线数目，便于布线，减小体积，提高系统的可靠性;•③便于接口设计，所有与总线连接的设备均采用类似的接口;④ 便于系统的扩充、更新与灵活配置，易于实现系统的模块化;⑤便于设备的软件设计，所有接口的软件就是对不同的接口地址进行操作;便于故障诊断和维修，同时也降低了成本。
    - 外部总线：与键盘等之间的总线。
  
### 网络模型硬件
+ 物理层
  - Modem（中继器）：将信号进行数模转换（模拟信号和数字信号的转换）
  - 集线器（交换机、路由）：将多个计算机设备的信号（数据）进行交换和路由，使它们能够相互通信。
+ 数据链路层
  - 网桥（网桥、交换机）：将多个计算机设备的信号（数据）进行交换和路由，使它们能够相互通信。
+ 网络层
  - 路由：连接不同的逻辑网络。
+ 应用层  
  - 网关：用于不同协议的应用程序的通信。


## 输入输出技术(重点DMA)
1. 程序控制方式：
   +  **无条件传输**：外设总是准备好的，无条件，随时接收和提供数据。
   +  **程序查询方式**：CPU利用程序来查询外设的状态，准备好了再传数据。
   +  **中断方式**：CPU不等待，也不执行程序去查询外设的状态，**而是外设在准备好以后，向CPU发出中断请求**以上三种方式都需要CPU的参与。
   + **DMA方式**：数据的传输是**在主存和外设之间直接进行，不需要CPU干预**，实际操作是由**DMAC硬件**直接执行完成的。通道方式和外围处理机方式：更进一步减轻了CPU对1/0操作的控制，更进一步提高了CPU的工作效率，但是是以增加更多硬件为代价的。**用DMA方式传输数据，每一个数据都需要占用一个总线周期。**

## 进制转化（小数部分为负次方）
1. B O D H(X),二 八 十 十六
2. 十六进制，11到15用A到F表示。
3. 八、十六进制转化为二进制：
   + 八转二，每一位数字写为3位二进制。
   + 十六转二，每一位数字写为4位二进制。

## IO基础
+ 计算机运行遇到突发情况会中断并保存现场（为了返回继续处理程序。）
+  I/O接口功能
   + 数据缓冲与暂存
   + 错误和状态检查机制
   + 操作的控制和定时
   + 数据格式转换
   + 与主机号和设备通信。
+ IO层级
  - 用户进程->与设备无关的系统软件->设备驱动程序->中断处理程序->硬件
## **周期**
   + 指令周期：是指执行一条指令所需要的时间。
   + **时钟周期：也称为振荡周期，是计算机中最基本的、最小的时间单位**在一个时钟周期内，CPU仅仅完成一个最基本的动作。
   + 总线周期：通常把CPU通过总线对存储器或1/0接口进行一次访问所需要的时间称为一个总线周期。
   + 储存器周期：是指CPU对存储器进行一次读写操作所需要的时间，也是MDA一次操作的时间。
   + CPU周期：又称为机器周期。CPU的操作速度快，但访问内存的速度却慢得多，我们把从**内存读取一条指令的最短时间，称之为机器周期**

### 流水线技术（取指令，解析指令，执行指令）
1. 流水线周期：最慢子任务执行时间。
2. 流水线执行N条指令需要的时间：T(取指令，解析指令，执行指令+T)+T(max(取指令，解析指令，执行指令))*N
3. 吞吐率(单位时间指令的执行数量)：1/TT(max(取指令，解析指令，执行指令))
4. 加速比：S=T(流水线执行)/T(不使用流水线执行)

## **关系代数基础**
### 关系运算
+ 属性个数不同，不可进行并、交、 差运算，RxS:R和S的笛卡尔积,**R÷S运算的结果是一个关系，包含了在R中所有与S中每一个属性都有相关的属性。**
+ π：选择运算， πA(R)：选择集合中与属性A的值相同的属性，并去重。
+ σ：投影运算，σA(R)：选择集合中满足条件A的属性，有多个需同时满足的条件时用^连接（Eg:σ1=2^3>5）
+ ⊳⊲：连接运算，将两个表进行自连接运算，进行连接运算时结果属性为A、B中的不重复属性集。（重复保留其一）
+ 进行笛卡尔积运算后结果属性为A、B中的所有属性集,**在运算中所有数字表示第N个属性**
+ F+：超集，除含有F本身属性外还含有额外属性，CF+为用属性C可退出的所有属性（此处F为关系集合）。
### 函数依赖公理
+ 传递率：若A->B，B->C，则A->C。
+ 增广率：若A->B，则AC->BC。
+ 伪传递率：若A->B,BD->C,则A->C。
+ 合并率：A->B,A->C,则A->BC。
+ 分解率：若A->BC,则A->B,A->C。


## 相关法律
+ 保护计算机箸作权:著作法，软件保护条例。
+ 商标到期可续，三年不用别人可申请注销。

## 数据效验
### 效验方法
+ 水平奇偶校验（Horizontal Parity Check）：水平奇偶校验是在数据的每一行 （即水平方向）上将数据划分为多个字节或位组，为每个组添加一个额外的效验位，使得每个组中“1”的个数为奇数或偶数（取决于所选的奇偶校验类型）。（**接收后可检验‘1’是否为奇（偶）数**）

+ 垂直奇偶校验（Vertical Parity Check）：垂直奇偶校验是在数据的每一列（或称为“垂直”方向）上进行的，其他同水平奇偶。

+ 海明码（Hamming Code）：
  - 它通过在数据中添加多个冗余位（校验位）来实现错误检测和纠正。这些校验位被放置在数据中的特定位置，以便能够**检测并纠正单个位错误**
  - 若满足：有效位N位效验位K位时，2**K >= N+K+1者可检测并自动纠错每一位。

+ 循环冗余校验（CRC, Cyclic Redundancy Check）：基于二进制除法原理的错误检测算法，它通过将数据附加一个额外的校验值（CRC值）来实现错误检测。该CRC值是通过将数据作为被除数，**通过预定的除数（称为“生成多项式”）进行模2除法得到的余数。**接收方使用相同的生成多项式对接收到的数据（包括CRC值）进行模2除法，如果余数为零，则数据很可能是完整的。


# 计算机体系结构和存储结构
## 计算机体系结构分类：
+ 处理机数量分类：
  - 单处理器系统
  - 并行与多处理系统
  - 分布式处理系统（采用时间片段轮转算法，将CUP时间划分为多个片段）
+ 微观上按并行程度分类：
  - Flynn分类法
  - 冯泽云分类法
  -  handler分类法等
## 储存系统：
### 存储器的分类：
+ 按存储器所处的位置：可分为内存和外存。
+ 按构成存储器的材料：可分为磁存储器、半导体存储器和光存储器。
+ 按存储器的工作方式：可分为读写存储器和只读存储器。
+ 按访问方式：可分为按地址访问的存储器和按内容访问的存储器。按寻址方式：可分为随机存储器、顺序存储器和直接存储器。
+ 随机访问存储器：
  - 静态随机访问存储器(SRAM)
  - 动态随机访问存储器(DRAM)
### 高速缓存系统
   * 简介：Cache是介于CPU与主存之间的一级存储器，其容量较小，但速度较快，一般比主存快5～10倍，**但是比寄存器慢**
   * 作用是：**调和CPU的速度与内存存取速度之间的差异，从而提升系统性能。**
   * 它使用的是程序的局部性原理，其内容是主存局部域的副本。
   * 当CPU需要读取数据时，首先判断要访问的信息是否在Cache中，如果在即为命中，如果不在，就要按替换算法把主存中的一块信息调入Cache中。替换算法有：随机替换算法、先进先出替换算法、近期最少使用替换算法、优化替换算法等。
   * CPU工作时给出的是主存的地址，要从Cache存储器中读写信息，就需要将主存地址转换成Cache存储器的地址，这种地址的转换叫作地址映像。
   + 地址映像方式：
     * **直接映像**：直接映像：主存的块与Cache块的对应关系是固定的，主存中的块只能存放在Cache存储器的相同块号中。优点：地址变换简单、访问速度快。缺点：块冲突率高、Cache空间得不到充分利用。
     * **全相联映像**：主存与Cache存储器均分成容量相同的块。允许主存的任一块可以调入Cache存储器的任何一个块的空间中。优点：灵活，块冲突率低，只有在Cache中的块全部装满后才会出现冲突，Cache利用率高。缺点：无法从主存块号中直接获得所对应Cache的块号，变换比较复杂，地址变换速度慢，成本高。
     * **组相联映像**：是前两种方式的折衷。将Cache中的块再分成组。组采用直接映像方式而块采用全相联映像方式。主存的任何区的0组只能存到Cache的0组中，1组只能存放到1组中，依此类推。而组内的块可以存入Cache中相同组的任一块中。公式：主存地址位数=区号+组号+主存块号+块内地址Cache地址位数=组号+绍内块号+块内地址
+ **编码的计算**：
  - 需要编号数目转化为二进制数，有几位即需要几位数字来储存。（1MB=2**10KB）
  - 用位视图记录磁盘使用情况：
    - 磁盘为1024GB，一块储存4MB,电脑为64位问需要多少字节来记录磁盘的使用情况：1024*1024/4/64=4096字节。 
+ 磁盘碎片整合
  - 作用：将磁盘碎片整合到连续的磁盘块中，以减少磁盘碎片，**提高系统对文件和文件夹的访问速度**
## 对称加密技术
+ 定义：文件加密和解密使用了相同的密钥，或者不同但是易从一个推出另一个。
+ 代表算法：
  - DES：主要采用替换和移位加密，用56位的密钥对64位的二进制数据块进行加密。
  - 3DES：用两个56位的密钥。
  - RC-5：
  - lDEA:类似DES，但密钥为1289位。
  - AES：基于排序和置换运算进行加密。
## 非对称加密技术
+ 定义：文件加密和解密使用一对密钥，加密密钥和解密密钥，公钥是公开的，私钥是非公开的。
+ 加密模型：数据用公钥加密后发送，仅有私钥可解密数据。(公钥是公开的，私钥是接收者持有的。)
+ 认证模型：用私钥加密后由公钥持有者进行解密。
+ 代表算法：
  RSA，基于大素数分解的困难性。
+ 特点：保密性好，无需频繁交换密钥，但是加密解密时间长，不适合对文件加密。
## 信息摘要(数据指纹)
+ 哈希函数：输入不定长字符串，返回定长字符串又称为哈希值（MD5码）。
+ 单向哈希函数：用于产生信息摘要。
+ 对于特定的文件，信息摘要唯一。（可判断信息是否被篡改，通过哈希值是否一致）
+ 由哈希值不可推出原文。
+ 数字签名中，可解决验证签名和用户身份验证、不可抵赖性问题。(认证模型升级版)
  - 用哈希函数生成MD5码并用私钥加密，加密后的信息和已加密的MD5码一起发送给接收者，接收者用同样的哈希函数生成MD5码与公钥解密后的MD5码比较(**可确认发送者的身份和信息是否被修改过，但是信息不保密**)。
+ 数字加密（数字信封）(加密模型升级版)
  - 先用对称密钥K加密得到密文D，再用接收者的公钥对密钥K加密得到K1，发送K1和D。(**可保证信息保密，但无法确定信息来源**)
+ MD2，MD4,MD5是广泛运用的哈希函数，产生128位的摘要。(MD为信息摘要的英文简写)

## 计算机安全原则
+ **最小权限原则**：最小权限原则是指系统中的每个用户都应该被赋予最小的权限，从而减少被攻击的风险。
+ **开放设计原则**：计算机的系统和安全设计应该开发，**仅通过对敏感信息的保护保证安全**
+ **简化设计，经济实惠**
+ **最少公共原则**：在多用户系统中，应该尽量减少用户之间共享的信息，以减少被攻击的风险。
  

## 计算机的可靠性
+ 概念：
 -  计算机系统的可靠性:是指从它开始运行(t=0)到某时刻t这段时间内能正常运行的概率，用R(t)表示。 
 -  计算机系统的失效率:是指单位时间内失效的元件数与元件总数的比例，用入表示。 
 -  平均无故障时间(MTBF):两次故障之间能正常工作的时间的平均值称为
平均无故障时间 MTBF=1/入.
 - 计算机系统的可维修性:一般平均修复时间(MTRF)表示，指从故障发生到机器修复平均所需的时间。 
 - 计算机系统的可用性:指计算机的使用效率，它以系统在执行任务的任意时刻能正常工作的概率A表示。A=MTBF/(MTBF+MTRF)
+ 串联和并联系统
  - 串联系统可靠性：R = R1*R2*...*RN
  - 并联系统可靠性：R = 1-(1-R1)*(1-R2)*(1-RN)

# 程序语言知识

## 耦合与内聚
### 耦合
+ 非直接耦合：无直接关系，联系完全依赖主程序调度
+ 数据耦合：通过数据参数来交换信息
+ 标记耦合：通过一组模块（数据结构）交换信息
+ 控制耦合：传递开关、标记等控制信息来控制其他模块 
+ 外部耦合：使用共同是全局变量
+ 公共耦合：使用共同是全局数据结构
+ 内容耦合： 一个模块直接访问另一个模块内部数据或不通过正常的入口进入
### 内聚

## 编译、网络模型 、病毒等基础知识
### 程序语言概述
+ 低级语言：机器语言和汇编语言。
+ 高级语言：编程语言
+ 汇编：用汇编语言写的程序，需要用汇编程序进行翻译成目标程序。
+ 解释与编译：用高级语言写的，需进行解释或者编译。
### 编译与解释程序
+ 解释程序(解释器)：
  逐条解释与运行。
+ 编译程序(编译器)：
  先将源程序编译为目标程序，执行目标程序。  
+ 对比：
  - 编译效率高
  - 解释更灵活更好移植。
### 程序语言的数据成分和控制成分
+ 数据成分
  - 常量和变量，数据类型。
+ 控制成分：
  - 顺序结构
  - 选择结构
  - 循环结构
### 编译的过程
+ 前端：(词法分析，语法分析，语义分析，中间代码生成)
  - 词法分析：检查单词符号错误(单词包括符号)
  - 语义分析：检查语法错误，若无错则可正确构造语法树。
  - 语义分析：检查语义错误(如整除对象为float型)。
  - 中间代码分析：根据语义分析输出生成中间代码(常见有后缀式，四元式，树形表示)。
  - 与高级语言相关，多种语言的程序在同一机器上运行修改前端。
+ 后端：(代码优化，目标代码生成)
  - 代码优化：将中间代码或目标代码进行优化其空间效率和时间效率。
  - 目标代码生成：将中间代码转化为绝对的指令代码，可重定位的指令代码和汇编代码。(与具体机器密切相关)
  - 与机器语言相关，一种程序在多台机器上运行修改后端。
### 三缀表达式
+ 三者的相互转行：
  - 中转前：
    * 按运算优先级加上括号
    * 把括号内的运算符提到当前括号前
    * 去除所有的括号
  - 中转后：
   * 按运算优先级加上括号
   * 把括号内的运算符提到当前括号后
   * 去除所有的括号
### 查找算法：
+ 顺序查找：
+ 二分查找：
+ 分块(索引)查找：根据关键字查找，先在索引表中查找，若索引表中无该关键字，则到索引块中查找。eg:成绩分为A~D四个块。  
+ 哈希表查找：
### 网络模型
+ OSI七层模型：理论化的模型，分层体系结构，每层为独立子系统便于实现和维护。
  + 硬件层： 
    - 1物理层：
  + 网络层：
    - 2数据链路层：
    - 3网络层：
    - 4传输层：
  + 软件层：
    - 5会话层：
    - 6表示层：处理数据传输的相关问题，如：格式转换、数据加密、数据压缩、数据格式化。
    - 7应用层：
+ TCP/IP四层模型：传输控制/网络协议。
  - 1网络接口层：  
  - 2网际层IP：
  - 3传输层（TCP或UDP）：
  - 4应用层：
+ 五层模型：
  - 物理层：规定物理接口的特性。
  - 数据链路层：相邻节点的数据传输，并进行流量控制。
  - 网络层：选择合适的路由。
  - 传输层：提供明文数据传输。
  - 应用层：为用户进程提供网络通信服务如http。

### 计算机恢复
+ 网络故障检测：硬件 -> 软件 -> 网络配置 -> 病毒查杀

### 恶意代码：隐蔽、传染、潜伏、破坏
+ 被动传播恶意代码分类：  
  - 计算机病毒：
    -  引导型病毒：磁盘杀手病毒。
    -  宏病毒：Word宏病毒（批处理命令）
    -  多态病毒：逃避静态特征扫描，可通过行为查杀。
    -  隐藏病毒：隐藏文件的大小和时间加密等。
  - 木马：本地和网络
    - 文件捆绑法：将木马程序和文件捆绑在一起，用户打开文件时，木马程序随之启动。
    - 邮件炸弹法：将木马程序伪装成正常邮件，用户打开邮件时，木马程序随之启动。
    - web网站捆绑法：将木马程序伪装成正常网页，用户访问网页时，木马程序随之启动。
  - 间谍软件：主动执行用户不希望执行的程序。
  - 逻辑炸弹：条件触发破坏系统。
+ 主动传播恶意代码分类：
 - 陷门：允许特定用户登录系统。
 - 蠕虫：具有自我复制和传播功能，通过扫描IP段、端口、漏洞等，主动攻击其他计算机，**逻辑完整无需寄生于宿主程序**
 - 僵尸网络：将僵尸程序注入到其他计算机中，使其成为僵尸网络的一部分，并执行攻击指令。
 - 细菌：有自我复制功能的代码，通过大量复制来消耗CPU资源。 
+ 恶意代码检测：
  - 静态检测：
    - 基于特征：
    - 基于语义
  - 动态检测：
    - 基于行为：
#### 攻击方式
+ 生日攻击：本意是足够多的人一定存在生日相同的人，通过不同的输入有可能获得相同的哈希值，进而破解密码。
+ 彩虹表：通过大量穷举的哈希值，通过哈希碰撞来获得密码。
+ DOS（拒绝服务攻击）：通过发送大量请求，使服务器资源耗尽，导致无法提供正常服务。
+ DDOS（分布式拒绝服务攻击）：通过大量服务器同时发送请求，使服务器资源耗尽，导致无法提供正常服务。
+ TCP会话劫持：冒充客户端与服务器通信。
+ 直接注入攻击（SQL注入）：让服务器执行非法输入。
+ ARP攻击：通过发送伪造的ARP报文，将网络中的主机与路由器连接起来。
+ 中间人攻击：冒充服务器，拦截客户端与服务器之间的通信。
+ 网络钓鱼攻击：通过发送邮件，引诱用户点击链接，从而获取用户信息。
## 进程与线程
### 进程是最小的资源分配单元
+ 进程提供资源，线程占用必须的资源来执行任务。
+ 一个进程中的多个线程共享进程的资源，线程可以并发执行也可撤销其他线程。
+ 信号量：S=1：赋给初始资源。
+ P(X)：获取资源
+ V(X)：释放资源
#### 进程死锁的恢复
+ 强行剥其他进程的资源，以满足死锁进程的需求。
+ 进程回退：部分进程回退到可回避死锁的程度。
+ 进程撤销：撤销进程，释放资源。
#### 进程状态的转换
+ 阻塞->就绪<->执行  (因为当进程的cup分配时间 用完后会进入等待态)
+ 有优先级较高的进程需要执行时，中断当前进程，为了能返回来继续执行。（因为总线仅允许一个进程运行）
  - 中断：CPU转移控制权，执行与中断相关的中断服务程序。在处理完中断事件后，CPU会返回到原进程继续执行。保证操作系统能够及时响应外部事件和异常，提高系统的稳定性和可靠性
### 线程（thread）最小的执行单元
+ 线程是程序执行流的最小单元，是CPU调度和分派的基本单位。
+ 不与同进程共享：程序计数器、寄存器、栈、状态字。
+ 共享：堆、全局变量、静态变量、文件描述符。
## 软件开发
### 软件需求分析：
+ 分析步骤：确定综合需求、分析系统数据需求、导出系统逻辑模型、修正开发计划、编写需求规格说明书。
+ 需求分类：功能需求（能干什么）、非功能需求（性能）、设计约束（法律限制、预算限制）。
### 软件生命周期
+ 软件定义、软件开发、运行维护三个时期组成。
+ 阶段：需求分析->设计->编码->测试->运行维护。
+ 常用开发模型：
  - 瀑布模型：至顶而下，依次进行，文档驱动，不易更改。
  - 增量模型：模块化开发，可拓展性高。
  - **螺旋模型**：从上至下，加上模块开发，结合了瀑布模型和原型模型，**首次引进风险管理**。
  - **V模型**：**测试**贯穿始终，迭代测试。
  - 原型模型：与瀑布相反，快速落实需求，解决需求不确定。
  - 敏捷模型：无文档，强调人的主观能动性。
### 数据流图
+ 建模：自顶而下，从抽象到具体。
### 测试
+ 白盒测试：根据程序结构设置测试用例，以发现错误。
+ 黑盒测试：不考虑程序内部结构，只考虑程序的输入和输出，保证功能完整正确，但无法保证程序数据结构的有效。
+ 动态渗透测试：模拟黑客对服务器进行攻击。
+ 模糊测试：通过输入非预期的输入，并检测输出是否存在异常。

## 软件成熟度模型CMM
|等级|特征|
|---|---|
|初始级|软件过程混乱，成功取决于个人努力，管理原始依赖个人反映|
|可重复级|建立了基本的管理来追踪项目进度和成本，可重现类似项目|
|已定义级|管理和开发标准化、过程化，开发和管理需使用已批准的标准|
|已管理级|对软件产品、过程有定量理解和控制|
|已优化级|进程有量化标准，过程不断改进|

## 图
### DFD数据流图
+ 成分：
  - 数据流：用箭头表示。
  - 加工（P）：用圆形或类矩形（角为弧线的矩形）表示，**内部为处理XX**
  - 数据存储（D）：用一组平行线或多加一条竖边表示，即未封边的矩形。（**内部文字通常为：XX信息，XX表**）
  - 外部实体（E）：用矩形表示。
### **UML图**（建模工具）
+ 可建立的模型：需求模型、功能模型、逻辑模型、设计模型、实现模型。
+ 为软件设计可视化模型、为软件系统建立构件、为软件系统建立文档。
#### UML包括的图
+ **类图**：展现了系统中的类、接口以及它们之间的静态结构和关系。
+ **对象图**：展现了系统中的对象之间的关系，**为类图的一个实例**
+ **序列图**：强调了以**时间顺序**组织的对象之间的交互活动。
+ **状态图**：展示系统在运行时状态的变化,场景的图形化表示。
+ **顺序图**：展示了对象之间的通信顺序。
+ **用例图**：展示了如何使用系统。
### 活动图
+ 关键路径：最长的路径。
+ 松弛时间：与关键路径的时间差。

## 协议：
### 常见的网络协议
+ TCP/IP:基于用户/服务器模式的服务系统。
  - Telnet:端口为23，支持命令模式和会话模式，采用明文传输，面向连接。
  - 提供可靠的数据连接和流量控制，提供端口寻址。
+ UDP/IP:基于用户/服务器模式的服务系统。
  - 提供不可靠的数据连接，不提供流量控制，但提供端口寻址。
### 文件传输——FTP协议：
+ 在服务器和客户端建立两条TCP链接，20端口用于数据连接，21端口负责数据控制传输命令和参数。
+ 匿名的FTP用户名为"anonymous"，密码为邮箱地址。多数的FTP服务器不允许上传、修改、删除操作。
+ 安全性：需要配置本地防火墙，否则难链接到指定端口。
+ 连通性：NAT模式下需要配置局域网端口映射。
#### 模式
+ 主动模式：客户端向服务器的21端口发送连接请求，服务器向客户端的20端口发送连接请求。
+ 被动模式：客户端向服务器的21端口发送连接请求，服务器向客户端发送连接请求。
+ com公司、net网络、org组织、gov政府、edu教育、mil军事、cn中国。
#### SSH协议：
+ 为远程登录会话提供安全性的协议。
#### IPSec协议
+ 基于IP协议，使用IPSec协议，端口500，提供VPN服务，工作于网络层。
#### Socks协议
+ 防火墙安全会话转化协议。
#### SFTP协议：
+ 套了一层SSH协议，使用22端口，数据传输需要通过安全通道进行。
#### FTPS协议：
+ 添加了传输层安全TLS和安全套接层SSL加密协议支持的拓展协议。
#### TFTP协议：
+ 基于UDP协议，使用69端口，传输速度快。
### HTTPS超文本安全传输协议
+ 基于HTTP协议，使用SSL/TLS协议，端口443。，工作于应用层。
### IP分配——DHCP协议
+ 集中的管理、分配IP地址，使网络环境中的主机动态的获得IP地址、网关地址、DNS服务器地址等信息，并能够提升地址的使用率。
### 域名解析——DNS协议
+ 域名解析协议，使用UDP协议，端口53，将域名解析为IP地址，多域名可对应一个IP地址，IP具有唯一性。
+ 域名：由数字与字母（不区分大小写）组成，以"."分隔每一级，最后为顶级域名。
+ www网站、mail邮箱、news新闻。
+ 解析流程：
  + 本地解析： 
    * 本地DNS服务器（浏览器加本地DNS缓存）：查询本地缓存，如果命中则返回结果，否则继续查询。
    * hosts解析：查询本地hosts文件，如果命中则返回结果，否则继续查询。
  + 递归查询：逐级递归查询，如果查询到则返回结果，否则继续查询。
+ ARP：将IP地址解析为MAC地址，A（IP）：address、R（翻转）：resolution、P：protocol（协议）。
### 邮件协议：
+ 邮件传输协议（SMTP），端口24.
+ 邮件访问协议（POP3），端口110.
+ 邮件阅读协议（IMAP），端口143.
+ 简单网络协议（SNMP），端口161.
+ SMB：服务器消息块，端口139，用于局域网文件共享。

## 网络安全与攻击手段
### 注入攻击
+ **SQL注入攻击**：通过在输入字段中注入SQL语句，达到欺骗服务器执行恶意的SQL语句，通过防火墙保护。
+ **XSS注入攻击**：注入脚本到网站或web程序中，用脚本攻击客户端。
+ 代码注入：注入代码攻击网站。
+ Xpath注入攻击：注入Xpath语句，达到欺骗服务器执行恶意的Xpath语句，获取私密数据。
### 网络安全防护
+ 网闸：网络安全隔离设备，是在两个不连通网络之间的硬件，在限制条件下传输数据。（无完整的网络连接、单向传输、数据格式认证）
+ 防火墙（借助硬件和软件）：在网络边界上，对流入流出的数据包进行过滤，阻止不符合规定的数据包通过。
  - 一代防火墙：包过滤，不检查数据。
  - 二代防火墙：应用代理、网关代理，基于协议的过滤，配置难速度慢。
  - 三代防火墙：状态检测技术防火墙，包过滤、应用代理、网关代理、数据包内容检测，配置简单、速度快。
+ IDS：入侵检测系统，对网络流量进行监测，发现异常情况，发出警告。（部署在内部、监控整个子网）
+ IPS（深度防火墙）：入侵防御系统，对网络流量进行监测，发现异常情况，采取措施。（部署在边界、抵御外部入侵、不防护内部攻击）
+ WAF：Web应用防火墙，对HTTP/HTTPS协议、SQL注入进行安全防护。
+ VPN：虚拟专用网络，在公共网络上建立专用网络，进行加密通讯。
+ 堡垒机：跳板机制，需要先访问堡垒机，再访问内部网络。

## **大数据**
+ 特点：数据量大、增长速度快、数据类型繁多、价值密度低、处理速度快、价值高。 

### 数仓
+ 特点：面向主题、集成的、不可更新的（相对稳定的）、随时间不断变化的、反映历史变化的数据集合。
+ 应用场景：
  - OLTP（On-Line Transaction Processing,联机事务处理）：快速响应，传统数据库主要应用，如银行交易。
  - OLAP（On-Line Analytical Processing,联机分析处理）：决策支持，数据仓库主要应用，如企业决策。

### 并行计算
+ 定义：多个处理器同时处理多个任务。MapReduce方法是经典的大数据并行处理技术。
#### MapReduce特点：
  - 常选择成本低易拓展的低端服务器。
  - 硬、软件出错可自动检测和恢复。
  - 将处理向数据迁移，计算节点优先处理本地数据，无法处理时就近选择可用节点。
  - 面向顺序式大规模数据磁盘访问处理。
  - 框架式结构，无需处理细节，**但需要定义任务和实现map函数和reduce函数**
  - 支持拓展，性能与节点成进线性相关。
#### 并行数据库（MMP）
  - 多节点并行数据库任务，缺点是弹性差、设计规划是认为节点数量固定；容错低，出现故障需要重新执行，仅适用于需求资源固定的程序。
  - 在复杂查询任务中比MapReduce更高效。

### 分布式与集中式的对比
#### 分布式优点
+ 体系结构灵活，经济实惠。
+ 可靠性高、可用性强、易拓展
+ 局部响应速度快，易与集成现有的系统
#### 分布式缺点
+ 存取结构复杂
+ 资源花费大（主要用于通信）
+ 数据安全和保密性难以保障。
+ 分布式数据库：CAP（C:一致，A:可以，P：区间容忍）

### NOSQL非关系型数据库
+ 特点：符合BASE（基本可用、软状态、**最终一致性**）、高可用、高扩展性、高性能、高可靠性、高可用性。
+ 应用场景：
  - 键值存储：缓存、数据缓存、数据存储、数据共享。
  - 文档型数据库：数据存储、数据共享、数据管理。
  - 列存储数据库：数据存储、数据共享、数据管理。
  - 图形数据库：数据存储、数据共享、数据管理。
#### NOSQL数据库分类：
  - 键值存储：Redis、Memcached。
  - 文档型数据库：MongoDB、CouchDB。
  - 列存储数据库：HBase、Cassandra。
  - 图形数据库：Neo4j、InfoGrid。


## **数据库（底层是数学）**
### 数据库模型
+ 层次模型（网络结构的特例）：树形结构，数据结构简单，查询效率低。（数据独立性和抽象级别不够）
+ 网状模型（对现实的抽象）：有向图，存取效率高，维护开发复杂，数据结构复杂，查询效率高。（数据独立性和抽象级别不够）
+ 关系模型（关系代数的抽象）：**二维表结构**，数据结构简单，查询效率高，使用sql查询，底层对开发者不可见，非关系数据库Nosql可能可以用部分的SQL查询。
  - 域：一组具有相同数据类型的值的集合。
  - 元组：一条记录。

#### E-R模型
+ 实体：可区分的事物或抽象概念。
+ 属性：实体所具有的特性或特征。
 - 域：属性的范围
 - 元或度：属性的个数
+ 联系：实体之间的相互联系。
+ 元组：记录，表的每个元素。
  - 分量：元组的一个属性值。
+ 码-键：唯一标识的体的属性集。
  - 超码：能唯一标识实体的属性集。
  - 候选码：能唯一标识实体的**最小属性集**，可有多个。
  - 主属性：候选码的属性。
  - 非主属性：除主属性外的属性。
  - 主码：候选码中选出的一个。
  - 全码：能唯一标识实体的属性集。

##### E-R图绘制
+ 强实体：单实线矩形框，表示实体。
+ 弱实体：双实线矩形框，表示弱实体。
+ 属性：椭圆形，表示属性。
+ 派生属性（由属性推导出的属性）：使用虚线椭圆型表示。
+ 多值属性（可能包含多个值）：双实线椭圆形，表示多值属性。
+ 弱联系：双实线菱形框，表示弱联系。
+ 强联系：单实线菱形框，表示强联系。
  - 1:1联系：菱形框中只有一条边，联系两段需要标记1。
  - 1:n联系：菱形框中有两条边。
  - n: m :p联系：菱形框中有三条边。
  - n:m联系：菱形框中有两条边，箭头两端分别有m个点。
+ [E-R图示](G:\Word-Markdown\Markdown-GitHub\图片\E-R-creat.png)
+ 注意事项
  - 多对多的联系要用N:M表示
  - 一个顶点可以有多条边连接多个属性

##### E-R图转换为关系模式
+ 每个实体转换为一个关系模式。
+ 多对多的联系转换为：将两个外实体的主键作为关系模型的组合主键，同时两个外实体的主键为此关系模型的外键。
+ **只有多对多的联系才需要单独转换为一个关系模式**，1:n转换时在N侧实体添加1段的主键作为N端的一个外键，1:1在任意一端添加外键即可。

##### E-R实体联系
+ 一元（递归）联系：同一个实体的实例之间的联系。
+ 二元联系：两个不同实体的实例之间的联系。
+ N元联系：N不同实体的实例之间实例的联系。


### 数据库设计
#### 专用术语
+ 强实体：后者的存在需要以强实体的存在为前提。
+ 弱实体：后者的存在不依赖于前者的存在,**使用双实线矩形表示**
+ 多值属性：可能存在多个值的属性。
+ 派生属性：由属性推导出的属性。
+ 部分实体：后者的存在需要以前者的一部分存在为前提。
+ 最小属性集：其中的关系函数左侧不含冗余属性，右侧为单属性。（不含冗余属性的集合，不在集合中的可通过函数推出）
+ 模式：实体、属性和联系的集合。
#### 数据库独立性
+ 外模式/模式映射:保证逻辑独立性，即应用程序（外模式）与逻辑结构（模式）分离。
+ 模式/内模式映射:保证物理独立性，即当数据物理储存方式改变而无需改变应用程序。
#### 数据库规范
+ MySQL：ACID(原子性、一致性、隔离性、持久性)
   - 行次序可交换，列次序也可交换。
+ NOSQL: BASE(最终一致性)
#### 设计流程与模型
##### 设计流程
+ 需求分析（系统说明书含文档、数据字典DD、数据流图DFD）
+ 概念结构设计（绘制E-R图）
+ 逻辑结构设计（将ER图转换为关系模式，并设置视图）
+ 物理结构设计（设计表和字段，确定数据分布、确定存储结构、确定访问方式。）
+ 数据库实施（建立表试运行）
+ 数据库运维。
##### 设计模型
+ **MYSQL数据模型三要素：数据结构、数据操作、数据约束**

#### 数据字典（数据的数据）
+ 数据字典：对数据库中所有数据项、数据结构、数据操作和数据库中使用的各种语言的详细描述。
+ 内容：数据项、数据结构、数据流、数据存储、处理过程。
+ 作用；数据字典和数据流图共同构成系统逻辑模型。

### **数据依赖**
+ 函数依赖（语义完整性约束）： 
  - 平凡依赖：只能决定自己，可无视的依赖
  - 非平凡依赖：可决定别人。
  - 完全函数依赖：需要和别人一起才能确定你。
  - 局部函数依赖：我的一部分即可决定你。
  - 传递函数依赖：我决定你，你决定别人，我决定别人。
+ 连接依赖：R所有属性在实例上投影，投影结果进行连接计算后结果还等于实例本身。
+ 多值依赖：一个值对应了多个属性。 
  - 函数依赖的多值依赖：属性值是1对1关系，任何函数都满足，为多值依赖的特例，即可反推回来。
  - 非函数依赖的多值依赖：属性值是1对多关系，部分函数满足。

### 数据库优化
+ 表合并：解决频繁访问两表的关联数据。
+ 水平分解：元组过多，拆分为多个表。
+ 物理分区：将数据存储在不同的物理位置，提高查询效率。
+ 垂直分解：对关系中的相关属性查询，可将相关属性分解出来。

### 数据库范式与数据更新异常
#### 术语介绍
+ 主属性：能唯一标识对象的属性。
+ 码：能唯一标识对象的属性集。
+ **候选码**：能唯一标识对象的属性集，可有多个。
  - 判断：**由候选码可推出所有的属性，使之闭包**
    - 只在FD右部出现的属性，不属于候选码;
    - 只在FD左部出现的属性，一定存在于某候选码当中; 
    - 外部属性一定存在于任何候选码当中;
    - 其他属性逐个与2,3的属性组合，求属性闭包，直至X的闭包等于U,若等于U,则X为候选码
+ 非主属性：不能唯一标识对象的属性。
#### update、delete异常
+ update异常：在修改某个非主属性是可能会影响到多行数据,而这个异常可能是由部分函数依赖导致、或传递函数依赖导致。
+ delete异常：在删除某个非主属性是可能会影响到多行数据，这个异常可能是由部分函数依赖导致、或传递函数依赖导致。
#### 范式介绍
+ 1NF：所有属性都不可分割。
+ 2NF：**消除了非主属性对候选码的部分函数依赖**
+ 3NF：**消除了非主属性对候选码的传递函数依赖和部分函数依赖**，仅有直接函数依赖，非主属性之间不存在函数依赖。
+ BCNF：**消除了非主属性和非主属性对候选码的传递函数依赖和部分函数依赖**（3.5NF，每一个关系模式中每个决定属性集合都含有候选码）
  -  若所有的关系模式都属于BC范式，则在函数依赖内已经彻底分解消除了插入和删除异常。
  -  所有主属性都完全依赖与每个不包含它的候选码。
  -  所有的非主属性都完全依赖于每个候选码。
+ 4NF：**消除3NF中非平凡且非函数的多值依赖**。
+ **模式分解**：分解后的模式与原模式等价（分解后可无损还原，保持函数依赖 ）
#### 范式分解
+ 分解为BCNF:第一步：先求最小依赖集。可以发现CE->G多余，因此最小依赖集为F={B->G,CE->B,C->A,B->D,C->D}。第二步：候码非码成子集。由于候选码为(CE)因此将CE->B划分出子集（BCE），而B->G，B->D左侧均不含主属性(C、E)中的任何一个故划分出(BG),（BD）第三步：此时剩余依赖F={C->A,C->D}剩余元素{A,C,D}检查发现函数依赖左侧都是候选码即完成BCNF分解，如果不满足则继续分解余下的。于是BCNF分解的最后结果为{（BG）,(BD),(ACD),(BCE)}。
+ 分解为3NF:在2NF基础上消除传递函数依赖，将传递函数依赖的末端属性删除，在新增加一个关系模式。
+ 参考：(模式分解)[https://blog.csdn.net/sumaliqinghua/article/details/86246762]
### 属性闭包
+ 属性闭包：属性依赖的集合。
#### 函数依赖公理
+ 自反律：X->Y，则Y->X。
+ 增广律：X->Y，Y->Z，则X->Z。
+ 传递律：X->Y，Y->Z，则X->Z。
+ 合取范式：X->Y，Y->Z，则X->YZ。
+ 伪传递规则：X->Y，WY->Z，则XW->Z被F所蕴含。
+ 分解规则：X->Y，Z->Y，则X->Z被F所蕴含。
#### 函数依赖闭包F+
+ 由一个属性直接或间接推出来的所有属性的集合。
#### 属性闭包X+（F右下标）
+ 将属性集合X中的属性X1,X2,X3,...,Xn进行闭包运算（带入函数中），得到的结果组成的集合称为X在函数F下的闭包。
### 数据库模式与映像
#### 三级模式（模式之间是相互独立的）
+ 外模式：用户可以直接使用的模式，称为“子模式”，视图层。
  - 用途：简化用户与系统交互，保证数据安全、保密。
  - 对应：应用程序视图、部分基本表，
  - 外模式与模式是多对一的关系。
  - 具体：通过DML进行CURD数据操作。
+ 模式：数据库中所有数据项的集合，逻辑层，描述数据逻辑结构和特征
  - 用途：储存什么数据，数据之间用什么关系。
  - 对应：数据库中所有基本表，
  - 具体：通过DDL定义结构（库、表、视图，不含具体值）
+ 内模式：数据库的逻辑结构和存储结构，数据库的“本体”，实体层。
  - 用途：存储数据，数据的储存方式、是否加密、是否有索引。
  - 对应：物理结构，储存文件。
  - 具体：底层数据储存方法和存取方法。
  - 内模式与模式是一对一的关系。
+ 其他
  - 内模式是客观存在的，是操作的基础。
  - 概念级数据库是数据库的一种逻辑、抽象的描述即模式。
  - 用户级数据库是用户与数据库的接口、是概念级数据库的子集。
  - 修改内模式：修改模式/内模式映像（物理独立性）
  - 修改概念模式（逻辑结构）：修改外模式/模式（逻辑独立性）
#### 两级映像（保证数据逻辑独立性、物理独立性）
+ 外模式-内模式映像：用户通过外模式访问数据库，由内模式提供数据。
+ 模式-内模式映像：数据库管理员通过模式访问数据库，由内模式提供数据。
### 完整性约束
+ 实体完整性：主属性唯一，不能为空。（属性为实体的一个特征，候选码为能唯一标识实体的属性集合，主属性为候选码码的所有属性，主码为候选码属性中一个属性）
+ 参照完整性：外码引用主码。（定义两表关系，常为其他关系模式住建）
+ 用户定义完整性（约束）：对某一列或几列的值进行约束，数据满足语义要求,列级约束可在定义时声明也可先定义后声明。
  + NOT NULL：非空约束
  + UNIQUE：唯一约束
  + PRIMARY KEY：主键约束
  + FOREIGN KEY：外键约束
  + CHECK：检查约束，即范围限制。
  + DEFAULT：默认值约束
### 数据库关系运算
+ 集合运算符：X 笛卡尔积 
+ 关系运算符（运算结束时要去重）：
  + 选择：σ
  + 投影：π，选择其中一部分符合条件的
  + 连接：两个等边三角形相对成8字形，θ：条件连接有，对笛卡尔积有条件的连接。 
  + 除：除号，同时在横向和纵向进行运算。
  + 象集：含X属性的所有项。


### **SQL语句：结构化查询语言**
+ 定义：关系数据库语言，用于与数据库通信的语言。SQL(Structured Query Language),注MySQL实现了SQL的大部分标准，但是也进行了拓展。
+ **特点**：
  - **综合统一**：数据定义、操纵、控制与一体，可独立完成数据库生命周期所有活动。（非关系数据库：分为模式定义语言和操纵语言，修改模式时必须停止运行数据库，转存数据，重新编译安装）
  - **高度非过程化语言**，不涉及具体算法，只涉及数据定义、数据操纵、数据控制等，面向过程。（非关系；面向过程）
  - 面向集合的操作方式：集合运算符，集合运算符的结果是集合。（非关系：面向记录）
  - **两种使用方式**：
    - 交互方式：用户通过命令行界面输入SQL语句，由系统解释执行。
    - 嵌入式方式：SQL语句嵌入在宿主编程语言程序中，由宿主语言程序解释执行。
  - **语法简单易用**：语言功能强，核心功能仅有9个动词
    - DQL(Data Query Language)：数据查询语言，用于查询数据，动词：SELECT
    - DDL(Data Definition Language)：数据定义语言，用于定义数据库对象，动词：CREATE、DROP、ALTER
    - DML(Data Manipulation Language)：数据操纵语言，用于对数据库中表的记录进行更新，动词：INSERT、UPDATE、DELETE
    - DCL(Data Control Language)：数据控制语言，用于定义数据库的访问权限和安全级别，动词：GRANT、REVOKE
#### MySQL权限管理
##### 用户管理
+ 密码修改
  - set password='123456'
  - alter user user_name identified by '555'
+ 用户名修改和登录锁定
  - rename  user old_name to new_name
  - alter user user_name account lock|unlock //锁定或解锁用户
+ 创建和删除用户
  - 创建：create user user_name[@host_name] [identified by 'passwd'设置密码] [account lock锁定登录] [password expire标记用户密码过期]
  - 删除：drop user [if exists] user1,user2 
##### 权限管理
+ grant(授权) ：分配权限给特定用户，若不存在则创建用户。
  - 格式：grant 权限1,权限2,… ON 数据库对象 TO 用户  [**with grant option** //可授权给其他用户选项]
  - 数据库对象：library.*数据库library中所有表，\*.\*所有数据库中的所有表，
+ revoke(消权)：收回已分配的权限。
  - 格式：revoke 权限1,权限2,… ON 数据库对象 FROM 用户
+ 注：特权只能由授予权限的用户撤销，或通过CASCADE（收回它分发出去的权限）选项撤销。
##### 角色管理
+ 角色：具有一定权限的身份，为用户赋予角色后会拥有角色的权限 。
+ 创建角色：create role [if not exists] role_name
+ 角色赋权也使用grant。
+ 为用户赋予角色：grant role_name to local_name
+ 激活用户角色：set default role all to local_name
+ 收回用户的角色：revoke role_name from local_name
+ 查看角色/用户权限：show grant for rol_name
#### SHOW与SQL常用语句
##### SHOW语句
+ SHOW VARLABLES LIKE '%datadir%'：查看数据库目录。
+ SHOW DATABASES：查看所有数据库。
+ SHOW DATABASES LIKE '%db_name%'：查看特定数据库。
+ SHOW DATABASES WHERE `Database` = 'db_name'：查看特定数据库。（其中Database为反引号，db_name为单引号）   
+ SHOW DATABASES WHERE `Database` LIKE 'db_name'：
##### SQL常用语句·
+ USE db_name：选择数据库。
#### 数据库定义
##### 数据库创建：CREATE
+ 创建数据库：CREATE DATABASE db_name [IF NOT EXISTS] DEFAULT CHARSET utf8mb4(字符集)
  - db_name：数据库名
  - DEFAULT CHARSET utf8mb4：指定数据库的字符集
  - [IF NOT EXISTS]：若数据库不存在则创建,**提高字符健壮性，不中断执行**
##### 数据库修改:ALTER
+ 修改数据库的默认（default）字符集：ALTER DATABASE db_name DEFAULT CHARSET utf8mb4
##### 数据库删除：DROP
+ 删除数据库：DROP DATABASE [IF EXISTS] db_name 
 - [if exists]:提高代码健壮性
#### 数据库表操作
##### 表创建：CREATE
+ 创建表：CREATE TABLE 表名(
  列名1 数据类型1 可选项, 
  列名2 数据类型2 可选项, 
  …
  )
  - **DEFAULT KEY/expr** ：指定默认值为KEY或表达式expr
  - **NOT NULL**:指定列不能为空，必须填写。
  - **PRIMARY KEY(col_name,col_class_id);**:指定**列非空集合**为主键，主键列的值不能重复，且不能为空,**此为单独一行定义注解，也可在行末加PRIMARY KEY直接定义为主键**
  - foreign KEY(col_name,col_class_id) **references** 主表名(col_name,col_class_id主键) **ON DELECT** CASCADE  **ON UPDATA** CASCADE：指定列非空集合为外键，外键列的值必须引用另一个表的主键,指定delect和update时是否级联。
    - **cascade**：级联，级联删除和级联更新。
    - **SET NULL**：置空，级联删除时将外键列置空。
    - **restrict、NO ACTIO**N：限制，级联删除禁止操作。
  - **USING BTREE**：指定采用二分查找
  - **UNIQUE** ：指定列的值唯一，允许为空，位置可随意。
  - **AUTO_INCREMENT**：指定列的值自动增长，**定义为自动增长后必须定义为键或主键、唯一键、外键，仅需在末尾加上auto_increment**
  - **COMMENT '入职时间'**：指定注释.
  - CREATE TABLE TABLE2 LIEK TABLE1：创建和table1结构相同的TABLE2。
  - 约束条件：
    - 主键约束：PRIMARY KEY //指定**列非空集合**为主键，主键列的值不能重复，且不能为空
    - 唯一约束：UNIQUE //指定列的值唯一，允许为空，位置可随意。
    - 默认约束：DEFAULT //指定默认值为KEY或表达式expr，无输入自动填为默认值。
    - 外键约束：FOREIGN KEY //指定列的值唯一，允许为空，位置可随意，限制主表的操作。
    - 检查约束：限定数据范围（创建表时 check 约束名（可省略） 条件）
+ 数据类型：
  - 数值类型：(需要定义无符号数值时直接在关键字后加**UNSIGNED**)
    - 整数(**INTYINT** 1位，**SMALLINT** 2位，**MEDIUMINT** 3位，**INTEGERT/INT** 4位，**BIGINT** 8位)
    - 浮点数(**FLOAT** 4位，**DOUBLE** 8位)
    - 定点数(**DECIMAL(M,D)**)16位，通过M指定精度，通过D指定小数位数，**用于精确计算**
  - 字符串类型：
    - **CHAR**(M) 0-255字节
     - **VARCHAR**(M) 0-65535字节**CHAR和VARCHAR存储时，会自动填充空格**
    - **BINARY**(M) 0-255字节,定长二进制字符串。
    - **VARBINARY**(M) 0-65535字节，不定长二进制字符串。
    - **TINYBLOB**(M) 0-255字节，不超过255个字符的二进制字符串，以一个字节来说明实际有多少数据。
    - **BLOB**(M) 0-65535字节，M为0-255，变长二进制字符串，保留2字节的前缀数据
    - **MEDIUMBLO**B(M),1677215,变长二进制字符串，保留3字节的前缀数据
    - **LONGBLOB**(M) 0-4294967295字节，变长二进制字符串，保留4字节的前缀数据
    - **TEXT**(M) 0-65535字节，变长字符串，保留2字节的前缀数据 
    - **MEDLUMTEXT**(M) 0-1677215字节，变长字符串，保留3字节的前缀数据 
    - **LONGTEXT**(M) 0-4294967295字节或4GB，变长字符串，保留4字节的前缀数据
  - 日期时间类型：
    - 日期
    - 时间
    - 日期时间
  - 枚举类型：枚举
  - 二进制类型：二进制、位
##### 表修改COLUMN（可省略）
+ ALTER TABLE table_nmae
  - **RENAME TO** new_table_name //重命名表
  - **RENAME COLUMN（可省略）** old_column_name **TO** new_column_name //重命名列
  - **ADD COLUMN** 字段定义 [FIRST/AFTER row_name] //添加字段,FIRST放于首列，AFTER row_name放于row_name之后，后接primary key可定义主键。
  - **DROP COLUMN** 字段名 //删除字段
  - **CHANGE COLUMN** old_col_name new_col_name col_definition [FIRST/AFTER row_name] //修改字段名和默认类型，可只修改一个但是要格式齐全如不改名，新名与旧名相同。
  - **MODIFY COLUMN** definition [FIRST/AFTER row_name] //修改字段类型。
  - ENGINE=INNODB //修改存储引擎
  - CONVERT TO CHARACTER SET utf8 //修改字符集
  - AUTO_INCREMENT=100 //修改自增起始值
  - PACKAGE_NAME=100 //修改自增步长
  - PACK_KEYS = {0|1|DEFAULT} //0表示不使用，1表示压缩字符串和整数，DEFAULT仅压缩长的字符串。
##### 表查看
+ (DESCRIBE/EXPLAIN/DESC) table_name //查看表结构
+ SHOW CREATE TABLE table_name //查看建表语句
##### 表删除
+ DROP TABLE [IF EXISTS] table_name //删除表
##### 表数据操作
###### 数据插入：INSERT、REPLACE
+ INSTER INTO
  - table_name(col_name1,col_name2,...) VALUES(value1),(value2); //插入1~n个数据，数据类型必须与列匹配，若为所有列不用给出列名，自增列和带有默认值列可以不用给出列名，赋值和列名需要对应。
  - table_name(col_name1,col_name2,...) ROW(value1),(value2); //插入1~n个数据.
  - SELECT col_name1,col_name2
    FROM table_name
    WHERE read_id < 4; //插入查询结果。
+ REPLACE类似INSERT，若插入数据与已有数据重复，则删除已有数据。
+ **插入子查询结果时：**无需values关键字。
###### 数据更新：UPDATE
+ UPDATE table_name
  SET col_name1=value1,col_name2=col_name2+10,...
  WHERE 条件
+ **嵌套子查询时：** 被更新的表不能出现在SET和where语句的字查询中。
###### 数据删除：DELETE、TRUNCATE
+ DELETE FROM table_name WHERE 条件 //删除满足条件的数据行
+ TRUNCATE TABLE table_name //删除表中所有数据，保留表结构，**先删除表再创建表，操作无法回滚，会有隐式提交即表已经删除但为创建**
###### 数据查询：SELECT
+ 格式：
  - **SELECT**  列名1,列名2,… **FROM** 表名 WHERE 条件
  - **SELECT** * **FROM**表名
  - 可选参数
    - distinct(去重查询，可选，为与SELECT之后，查询字段之前。 )
    - limit 2，3 //限制查询结果数量，从第2行（有第0行）开始，查询3行，仅写3为查询3行，**放于末尾**
    - order by col_name1,col_name2 //排序，默认升序ASC，可与末尾加desc降序。
    - order by rand() //随机排序。
    - group by
      - 末尾，可加with rollup，表示分组后求和
      - HAVING 条件 //分组后对行进行筛选，group by在where之后在order by之前。
      - 聚和函数（**与group by连用或在select中单独使用**）：SUM(col_ID)//计算ID之和 AVG(*)所有的平均值 MAX(emul) MIN(emul) COUNT(emul)，**聚合函数可以用于统计，也可用于边统计边判断，想要在where中查询含最大值的行，需要先用select语句查询最大值。eg:  having count(\*) > 5** ，但是不能用于where子句因为where用于过滤列是在确定列，而聚和函数是统计列where在前。
      - **count(*)统计非空行数，count(1)统计行数含非空行。**
      - 当group by有多个列名时会依次根据列名分组再组内分组，前面若有count（*）则只会聚合最小的分组。
    - select workaddres, conut(*) from emp where age < 45 group by workaddres having count(*) > 3;//查询年龄小于45的员工，根据工作地点分组，获取人数大于3的结果。
    - **范围查询**：where num **between** 10 **and** 20 //查询num在10到20之间的数。 
    
+ 基本查询：(执行顺序：from->where->select)

|ID|关键词|实例|
|:--:|:--:|:--:|
|1|SELECT(投影)|输入列名、表达式、集聚函数|
|2|FROM(笛卡尔积)|输入表名|
|3|WHERE(选择)|输入列名、表达式、逻辑运算符|
+ WHERE子句运算符：
  - 比较运算符：=、>、<、>=、<=、<>(不等于)、!=、(可a=3 and b=2 <=> (a,b)=(3,2) )
  - 逻辑运算符：AND、OR、NOT、XOR(仅满足一个条件)
  - 集合运算符：IN、NOT IN
  - 字符串匹配：LIKE、NOT LIKE
  - 其他运算符：等价：>=and=<
  - bewteen 100 and 200 //查询100到200之间的数据
  - publisher (not)in ('A','B') //查询出版社(不)为A或B的数据
  - 空值判断：IS NULL、IS NOT NULL
  - order by 列名1,列名2,… //排序，**默认升序，但是加上ASC可加快查询速度**，可指定多个列名，**若为降序则加DESC**
  - 正则表达式：
    - [abc]:匹配abc字符子集，[^abc]:匹配除abc字符子集以外的字符，[a-z]:匹配a到z的字符子集，[0-9]:匹配0到9的字符子集
    - .{m,n}:点代表任意字符可替换，匹配任意字符m到n次。
    - 特殊字符需要转义。
+ 连接（多表）查询（**指定需要的字段而不是\*可加快查询速度**）：
  - 内连接（join）：等值连接(公共属性连接)、不等值连接、自连接(将两个表看为一张表,去除了重复的列)
    - 隐式内连接：SELECT table_name.列名1,table_name.列名2 FROM 表1,表2 WHERE 条件
    - 显式内链接：SELECT table_name.列名1,table_name.列名2 FROM 表1 JOIN 表2 ON 表1.列名=表2.列名(连接条件)
  - 外连接(**需要保留N张表的完某整行信息**)：
    - 左外连接（完全包含左表信息包含部分右表）：SELECT table_name.\*,table_name.\* FROM 表1 LEFT JOIN 表2 ON 表1.列名=表2.列名
    - 右外连接：SELECT table_name.列名1,table_name.列名2 FROM 表1 RIGHT JOIN 表2 ON 表1.列名=表2.列名
    - 全外连接：SELECT table_name.列名1,table_name.列名2 FROM 表1 FULL JOIN 表2 ON 表1.列名=表2.列名
  - 自连接：SELECT 字段列表 FROM table_name AS 别名1 join table_name AS 别名2 ON 别名1.列名=别名2.列名
+ **联合查询union**：将多表查询结果合并为查询结果集
  - 条件：表的列数和字段类型需要保持兼容，多条查询语句用UNION连接，ORDER BY语句需要放在最后。
  - 合并结果集：**UNION(去重)、UNION ALL(不去重)**
  - Eg：SELECT 列名1,列名2 FROM 表1 where table1_id<5 **UNION**                                          SELECT 列名1,列名2 FROM 表2 where table2_id<8
###### **子查询（嵌套查询）**：
  - 标量子查询（结果为常量）：SELECT * from emp where dept_id=(SELECT dept_id from dept where dept_name='财务部')
  - 列子查询：IN(满足指定范围) NOT IN(不在此范围) ANY/SOME(列至少一个满足) ALL(列中所有都满足)                        eg:select ...>all(select ...)
  - 表子查询：in (select ...生成的表)
  - 行子查询：in (select ...生成的列)
  - **当用max函数查询结果需要用括号括起来，重复使用同一表需要取不同的别名**
###### 测试子查询
+ 通常与where子查询一起使用可优化查询速度。
+
``` 
SELECT column_name(s)
FROM table_name
WHERE EXISTS (subquery);
```
+ EXISTS 子查询若查询到一行结果，则 EXISTS 条件会返回 TRUE并终止子查询；否则，返回 FALSE。
###### **窗口函数子查询**
+ 不改变返回的行数，但可以通过计算为每一行分配一个值。
+ 基本语法
```
SELECT
    column1,
    column2,
    window_function(column3) OVER (
        [PARTITION BY partition_expression]
        [ORDER BY order_expression [ASC | DESC]]
        [window_frame_clause]
    ) AS alias
FROM
    table_name;

```
  - 当需要重复利用一个窗口函数时可在SQL语句之后定义一个窗口（window w as (parititon by id oreder by sala desc)），在查询中通过 函数类型 over w 字段名 调用。
  - window_function: 窗口函数的类型，例如 SUM、AVG、ROW_NUMBER、RANK、DENSE_RANK，排名窗口函数不支持分区，**一个查询中可对应多个字段有多个窗口函数。**
    - row_number:生成序列号。
    - rank：无并列排名函数。
    - dense_rank:有并列排名函数。
    - percent_rank:无并列排名函数，返回排名占比。
    - cume_dist:计算排名在当前行之前行的行数。
    - ntile:将数据拆分为N等分，返回当前数据在第m等分。
  - over(): 定义窗口函数的使用范围和窗口特性。
  - partition by: 按指定的列或表达式进行分区，窗口函数将在每个分区内计算。如果不使用partition,则整个结果集被视为一个分区。
  - order by: 指定排序顺序，通常是rank函数。
  - window_frame_clause: 指定数据聚合范围。常见的窗口类型有 RANGE（以数值为单位如10天） 和 ROWS(以行为单位)，用于指定窗口的行集合。 
    - rows between unbounded preceding and current row: 窗口从第一行开始，到当前行结束。
    - range interval '5' day preceding: 窗口从当前行向前 5 天开始,interval 指定时间间隔。
    - unbounded preceding: 窗口从第一行开始。
    - unbounded following: 窗口到最后一行结束。
    - current row: 窗口从当前行开始，到当前行结束。
    - between ... and ...: 窗口从指定行开始，到指定行结束。
    - n preceding: 窗口从当前行向前 n 行开始。
    - n following: 窗口从当前行向后 n 行开始。
###### **范围限定**
+ between……and：在此范围的结果返回。
+ not between……and：返回不在此范围的结果。
+ in：返回在集合中的结果
+ all：返回大于集合中任意值的结果。
+ any：返回大于集合中所有值的结果。
+ not in：返回不在集合中的结果。
+ not all：返回小于集合中所有值的结果。
###### **常用函数**
  - 字符串函数
    - concast(str1,str2),字符串拼接。
    - lower、upper大小写转换
    - length(str),长度计算。
    - trm(str),去除前后空格。
    - lpad(str,n,pad),左填充至n位。
    - rpad(str,n,pad),右填充至n位。
    - substrate(str,start,len),截取指定位置长为len字符串。
  - 数值函数
    - round(x,n),保留n位小数，四舍五入。
    - ceil(x),向上取整。
    - floor(x),向下取整。
    - mod(x,y),取x/y的模。
    - rand(x),0~1随机数。
  - 日期函数
    -  curdate(),返回当前日期。
    -  curtime(),返回当前时间。
    -  now(),返回当前日期和时间。
    -  year(date),返回date的年份。
    -  month(date),返回date的月份。
    -  day(date),date的天数。
    -  date_add(date,interval(关键字) expr(大小) type(单位)),返回日期date加上interval expr type后的日期。
    -  date_sub(date,interval expr type),返回日期date减去interval expr type后的日期。
    -  datediff(date1,date2),返回日期date1-date2的天数。
  - 流程控制函数
    - if(value>1,t,f) //若满足返回T
    - ifnull(value1,value2) //若value1不为空返回value1
    - case when [value=1] then [result] ... else  [result2] end 【as 等级(给新列命名)】  //ralue为真返回result否则返回default默认值。
    - case [expr] when [value] then [result] ... else [default] end //若expr=value返回result否则返回default默认值。

##### SQL查询优化
+ **总纲：中间结果要小，磁盘调用要少，先筛选再连接**
+ 选择运算尽可能先做。
+ 将投影和选择运算合并为一个连接运算。
+ 把投影同其前后的双目运算结合。
+ 将选择和在其前的笛卡尔积运算结合为连接运算。
+ 找出公共子表达式。
+ 减少多表查询、子查询、物化视图。
+ where中用IN运算代替OR运算。
+ 避免使用"%string"的全局扫描，而使用"string%"的字段索引扫描。
+ 使用UNION ALL 而不是UNION因为后者包含去重操作。

#### SQL窗口函数(mysql8.x)
+ SELECT 
    column1, 
    column2, 
   function() OVER (
    partition by column1 order by column2) 
    AS new_cname
  FROM table_name;
  - partition by：指定分组字段
  - order by：指定排序字段
##### window_founction
+ 序号函数（分组排序，并添加序号）
  - row_number()、rank()、dense_rank()//row_number()为不重复排名，rank()为有并列排名，dense_rank()为有并列且连续排名
+ 聚合函数
  - sum、avg、max、min、count
+ 分布函数
  - cume_dist():返回小于等于当前值的百分比。
  - percent_rank():计算当前行在结果中的百分比排名。
+ 偏移函数
  - lag(col,n,default):返回当前行往前第n行的值，若没有则返回到default行。
  - lead(col,n,default):返回当前行往后第n行的值，若没有则返回到default行。
+ 首尾函数
  - first_value(col):返回当前窗口的第一行值。
  - last_value(col):返回当前窗口的最后一行值。
+ 其他函数
  - nth_val(expr,n):返回当前窗口的第n个expr值。
  - ntile(n):将窗口中的行分为n个桶，返回当前行所在的桶号。
##### window_over
+ partition by：指定分组字段
+ order by：指定排序字段

#### SQL编程
##### 基础知识
+ 注释：#放在行末、-- 在行末，--要加一个空格
+ 定界符：默认为‘ ; ’，可用DELIMITER \$\$ 重新定义为($$、@@等)后待函数定义完后重新定义为‘ ; ’
##### 变量与运算符
+ 全局变量：@@变量名，全局变量会影响整个数据库实例，通过show variables like '%变量名%'或select @@version查看。
+ 会话变量：@变量名，会话变量只影响当前连接，创建连接时自动复制全局变量为会话变量。
+ 用户变量：基于会话变量实现，用户变量分为系统变量和用户变量，系统变量以@@开头，用户变量以@开头。
+ 局部变量：定义在begin...end语句中。
+ **定义**:declare 变量名 数据类型 （default 10设置默认值为10可选）;
  - **一次定义多个变量：declare 变量名1 数据类型1,变量名2 数据类型2,...;**
+ 赋值：
  - 用户变量：
    - 方式一：set @变量名=值
    - 方式二：set @变量名:=值
    - 方式三：select 值 into 变量名 from 表
  - 局部变量：（用BEGIN ...END界定作用域）
    - SET 变量名 := 值 ；
    - SET @变量名='经济学'
+ 运算符：
  - 算术运算符：+ - * / %，其中%和/除数为0时返回NULL。
  - 比较运算符：同SQL语句，BETWHEEN x and y(介于x与y之间)，结果为TRUE、FALSE、null（未知，当比较双方一方为null时无法比较故结果为未知）
  - 位运算符：&、^异或、|、~、>>、<<
###### 通过select语句赋值
+ 
```
SELECT SUM(score)
INTO :a,:b,:c
FROM student_scores
WHERE student_id = 12345;
```
##### 流程控制
+ 用begin……end定义语句块。
+ IF
```
IF 条件 THEN
    语句1;
ELSEIF 条件2 THEN
    语句2;
ELSE
    语句3;
END IF;
```
+ CASE
```
CASE 变量
    WHEN 值a/a>10 THEN 语句1(eg:set cj='A')
    WHEN 值2 THEN 语句2
    ELSE 语句3
END CASE;
```
+ LOOP(死循环，**在MySQL用LEAVE语句跳出，iterate跳过本次循环，在SQL中使用exit跳出**)
```
LOOP
    语句1;
END LOOP;
```
+ WHILE
```
WHILE 条件 DO
    语句1;
END WHILE;
```
+ repeat（相当于do……while，但是是条件不成立是执行语句）
```
REPEAT
    语句1;
UNTIL 条件
END REPEAT;
```

##### 函数
+ 格式化函数
  - cast(X as type) //将X转换为type类型，type为字符串、整数、浮点数、日期等。
  - CONVERT(X ,type) //将X转换为type类型。
  - COMVERT(X  USING charset_name) //将X转换为charset_name字符集。
  - FORMAT(X ,D) //将X格式化为D位，D为0时返回X的整数部分。
+ 加密、压缩函数
  - MD8(str) //将str进行MD8加密为32位16进制数
  - SHA1(str) //为str生成160位效验码。
  - COMPRESS(str) //压缩str，返回压缩后的二进制数据。
###### 自定义函数
```
DELIMTER $$ //重新定义界定符为$$防止与SQL语句冲突
CREATE FUNCTION 函数名(参数列表)
RETURNS INT //返回值为int型
(NO)CONTAINS SQL //指定函数特征参数，（不）包含SQL语句。
BEGIN //
    函数体
END $$ //
DELIMITER ; //
```
+ 特征参数
  - (NOT) DETERMINISTIC //函数是否具有确定性，即每次输入相同参数时，函数是否返回相同的结果。
  - (NO) SQL //函数体是否包含SQL语句。
  - READS SQL DATA //函数体是否读取了数据库数据
  - MODIFIES SQL DATA //函数体包含写数据据
  - SQL SECURITY (INVOKER/DEFINER) //函数的安全性，INVOKER表示由调用者决定，DEFINER表示由创建者决定。
+ 函数的调用:SELECT 函数名(参数列表) FROM 表名
+ 查看自定义函数：SHOW FUNCTION STATUS (LIKE '函数名'/ /where);
+ 删除函数：DROP FUNCTION IF EXISTS 函数名;

#### 索引（快速访问）
##### 索引的分类
+ 普通索引、唯一索引、主键索引、空间索引（为空间数据创建，只有MyISAM引擎支持）、全文索引（仅适用于文本数据（text、varchar、char），只有MyISAM引擎支持），CLUSTER聚簇索引：按一定的顺序分组排列并重新储存数据。
+ 加速了select但是减缓了数据更新，因为更新数据同时也需要更新索引。
+ **利与大部分查询的索引：设为聚簇索引。聚簇索引和非聚簇索引都是B+树索引。**
##### 索引的创建
+ 创建表时创建索引
  - create table 表名(
    字段1 数据类型,
    字段2 数据类型,
    [unique唯一|fulltext全文|spatial空间] index|key [index_name](可选字段名) (idex_col_name(指定对应字段) [(length(可选指定索引长度))] [ASC|DESC])
  );
+ 创建索引
  - CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name(索引名)
  ON 表名(index_col_name(指定对应字段) [(length(可选指定索引长度))] [ASC|DESC])
  eg:CREATE INDEX idx_name ON employee (name); //在employee表的name列上建立名为idx_name的索引
  - ALTER TABLE 表名字 ADD INDEX 索引名 (列名);eg:ALTER TABLE employee ADD INDEX idx_id (id);  #在employee表的id列上建立名为idx_id的索引
+ 删除索引
  - DROP INDEX index_name ON 表名;
  - ALTER TABLE 表名 DROP INDEX 索引名;
+ 查看索引：
  - SHOW INDEX FROM 表名字; 查看刚才新建的索引 

#### 视图(从一表或多表或视图中导出的虚表)
##### 视图的定义与分类
+ 定义：是虚拟表，数据库中只存放视图的定义，用于用户查看时只查看特定的数据。
+ 分类：普通视图和检查视图（加入了 with check option 子句）
##### 视图的创建
+ 创建视图
  - CREATE   VIEW   视图名(col_name1(视图中的列名),col_name2(可省略，则默认为SQL语句中的查询列名 )) AS SELECT 查询语句;
+ 使用：
  - 为虚拟表但是创建完成后可将其视为基本表使用。
+ 删除视图
  - DROP VIEW view_name;
+ 查看视图
  - DESC view_name;;
  - SHOW table status like 'view_name';
+ 修改视图
  - ALTER VIEW 视图名 AS SELECT 查询语句;
+ **视图的更新限制**
  - 视图的更新只有部分可更新原表（即：视图列中不含聚合函数、不是通过计算得到的列、不来自多个表（但若创建更新规则则可以）、不含分组，排序语句）。
+ 检查视图：(仅有满足视图定义时的where条件才会修改操作)
+ 需要增加的可选子句
  - with [ |cascaded ]check optionn//级联检查视图
  - with local check option//本地检查视图，简单的数据验证。

### 触发器trigger，一个表最多有6个触发器
+ 特点：不能存在于视图、临时表、存储过程、触发器、用户定义函数和**事件中**，**它是定义在实体表上的一种特殊储存过程**，不可包含DDL数据库定义和DCL数据库控制语句。，
+ 触发器：在满足一定条件时，自动执行的SQL语句。
+ **触发器原理**：创建了临时视图存放被修改的旧值和新值,可以利用次临时视图来保证更新后的数据满足在一定范围内。
  - 行级触发：默认OLD|NEW,通过如OLD.id访问修改前的数据。
  - 语句级触发：默认为OLD_TABLE|NEW_TABLE,通过如OLD_TABLE.id访问修改前的数据。
+ 创建：创建触发器：create trigger 触发器名 before/after （insert、update、delete触发事件） on 表名 for each row when(条件) 触发器体
  - before：在事件之前触发，after：在事件之后触发。
  - for each row：行级触发。
  - for each statement：语句级触发，若涉及多条记录也仅触发一次。
  - 当事件发生且满足条件时，触发器才会执行。
+ insert、delete是修改一行的触发事件，可用insert or delete创建两者都可触发的触发器，而update可以是修改一行的触发事件也可是修改一个值触发（**update of 列名 on table_name**）。
+ 修改：alter trigger 触发器名 disable/enable
+ 删除：drop trigger 触发器名


### 储存过程
#### 储存过程
##### 基础
+ 定义：封装的SQL语句集，存储在数据库中，可以被反复调用，**可使用SQL编程**
+ 特点：封装、复用、减少网络流量、可接受参数也可返回结果。
##### 使用
+ 创建procedure：
```
delimiter $$
CREATE PROCEDURE 储存过程名(IN vuel1 int，OUT result char)
BEGIN
    SQL语句集
    select result; //将结果result返回
END;
delimiter ;
```
+ 调用：CALL 储存过程名(参数);
+ 查看：
   - SHOW CREATE PROCEDURE 储存过程名;//查看其定义过程。
   - select routine from mysql.proc where db='数据库名' and routine_name='储存过程名';//查看其储存过程及状态信息。
+ 删除：drop procedure 储存过程名;
+ 修改：
+ 错误处理：
###### 参数
+ 参数类型：IN(输入参数)、OUT(输出参数)、INOUT(输入输出参数)
+ create procedure pro_name(IN 参数名 参数类型，OUT 参数名 类型)
##### **游标 cusor**
+ 定义：存储结果集的数据类型，使用游标可以对查询结果进行遍历。
+ 声明(**在变量声明之后声明**)：**DECLARE 游标名 CURSOR FOR select子句**；
+ 打开：OPEN 游标名；
+ 关闭：CLOSE 游标名；
+ 读取：fetch 游标名 INTO 变量名；
+ 删除：DELETE FROM 表名 WHERE 条件；
+ 更新：UPDATE 表名 SET 列名=值 WHERE 条件；
+ 插入：INSERT INTO 表名(列名1,列名2) VALUES(值1,值2)；

### 数据库日志
#### 错误日志
+ 记录了服务器开启和停止及运行过程中的错误信息，默认是开启的。
+ 查看：SHOW VARIABLES LIKE 'log_error';
+ 设置：SET GLOBAL log_error='错误日志文件路径和文件名';
#### 审计日志
+ 作用：**记录数据库的操作和事件**，以便后续进行安全审计、故障排查、性能分析以及遵守合规性等方面的需求。
+ 如记录敏感信息的变更。
#### 二进制日志
+ 以二进制数据记录了DDL和DEL语句
+ 服务器提供了多种格式来记录
  - STATEMENT:记录了进行修改数据的SQL语句。
  - ROW：基于行的日志记录，记录了一行的数据变更。
  - MIXED：混合STATEMENT和ROW两种模式，特殊情况会自动切换为ROW模式。
+ 查看：mysqlbinlog [option] log_name;
  - -d:指定数据库名，只查看特定数据库的日志。
  - -o:忽略日志中前N行数据。
  - -v:将数据以SQL语句形式显示。
  - -w:将数据以SQL语句显示并输出注释信息。
+ **日志储存**：储存花费空间较大，可通过配置文件设置超过设定时间自动删除。（binlog_expire_logs_seconds）
+ **日志恢复数据库**：通过二进制日志可对数据库进行恢复，故日志和数据库通常需要分开储存。
#### 查询日志
+ 记录数据库查询操作，默认关闭。
#### 慢查询日志
+ 记录执行时间超过阈值的SQL语句，默认关闭。

### 数据库数据的导入、导出、备份、恢复
#### 注意事项
+ 数据导入与导出属于敏感操作，必须要在指定的路径下进行（使用：-uroot show variables like '%secure%'命令查看）
#### 导入与导出
+ 数据文件的导入：LOAD DATA INFILE '文件路径和文件名' INTO TABLE 表名字;
+ 数据文件的导出：SELECT 列1，列2 INTO OUTFILE '文件路径和文件名' FROM 表名字;
#### 备份
##### 备份分类
+ **热备份**：在数据库运行时进行备份，备份期间数据库仍可正常使用，但备份期间数据库的修改无法被备份。
+ **冷备份**：在数据库关闭时进行备份，备份期间数据库不可使用。
+ **温备份**：在数据库运行时备份，但是备份期间数据库可读不可写。
+ 完全备份：备份所有数据，包括数据库、表、视图、存储过程、触发器、索引、日志文件等。
+ 部分备份：只备份数据库、表、视图、存储过程、触发器、索引等。
+ 增量备份：只备份自上次备份以来修改过的数据。
+ 差异备份：只备份自上次备份以来修改过的数据。
##### 简单备份操作
+ Linux：使用mysqldump会产生一个SQL脚本。
  - mysqldump -u root 数据库名 > 备份文件名;   #备份整个数据库
  - mysqldump -u root 数据库名 表名字 > 备份文件名;  #备份整个表
#### 恢复
+ source 备份文件路径
+ 也可创建一个新的数据库再导入数据（导入数据：mysql -u root test < bak.sql）

### **数据库故障与恢复**
+ 重做与回滚
  - 回滚（UNDO）：恢复到<start事务>之前的状态。
  - 重做（REDO）:回复到<commit事务>**之后**的状态。
+ **检查点**：出故障时日志从检查点开始读取对数据库进行恢复。
+ 是否满足事务持久化：在故障出现前已提交的事务满足持久化的条件。
+ 在检查点（CHECKPOINT）前已经提交的事务的事务无需操作，在检查点之后提交的事务需要重做，未提交的需要撤销。
+ 事务-DBMS(数据库管理系统)-操作系统-硬件
+ 恢复步骤：加载备份文件，将数据库恢复到备份前状态-启动数据库-执行日志-恢复数据。

|故障类型|故障原因|说明|故障描述|修复方式|备注|
|:--:|:--:|:--:|:--:|:--:|:--:|
|事务故障（**仅影响当前事务**）|程序执行错误（逻辑、运算溢出）|非法输入、系统锁死|在结束前终止|撤销故障事务|系统自动完成，系统重启后自动执行|
|系统故障（软故障）|硬件故障、软件漏洞|导致内存信息丢失，不破坏磁盘数据|事务提交后，部分数据可能已经入库导致数据不一致|重做已提交事务|系统重启后自动执行|
|介质故障|介质损坏|破坏了数据库，影响正在读取数据的事务|数据库操作破坏|重装数据库、装载备份和日志文件|需要DBA介入，在由系统撤销或重做|
|计算机病毒故障|由于计算机病毒导致数据被恶意修改或删除|需要杀毒|

### 数据库事件（event）
#### event基础
+ 定义： 定时（或隔相同的时间间隔）完成指定任务。
+ set global @ event_scheduler = 1;//设置事件开启
+ create event [if not exists] event_name on schedule [on completion [not]preserve] [enable|disable|disable on slave] do event_body
   - schedule：
     - at time：在指定时间执行。
     - every time_interval:隔指定时间执行一次
     - start time:指定开始时间。
     - ends time: 指定结束时间。
   - [on completion [not]preserve]是否仅执行一次，默认为仅执行一次。
   - [enable开启|disable关闭|disable on slave在从机中关闭]是否启用事件，默认为启用。
+ 删除：drop event event_name;
+ 修改：alter event event_name on 时间间隔 [on completion [not]preserve] [enable|disable|disable on slave] do event_body;

#### 事件类型
+ 定时事件：定时执行，时间间隔为指定的时间。
+ 间隔事件：间隔执行，时间间隔为指定的时间间隔。
+ alter 修改。
+ drop 删除。

### 数据库事务
#### 事务基础
+ 定义：数据库操作序列，满足ACID特性。
+ 特性：
  - **原子性（atomiction）**：不可分割，要么都执行，要么都不执行。
  - **一致性**：事务执行前后，数据库状态一致。
  - **隔离性**：并发事务之间相互隔离。
  - **持久性**：事务执行后，对数据库的修改是持久的。
+ 事务分类：
   - 自动提交事务，默认开启，每条SQL语句都是一个事务。
   - 手动提交事务，set @@autocommit = 0 //关闭自动提交，设置为全局手动提交，即任何操作必须手动提交才会对表进行修改。
+ CHECKPOINT：检查点，记录事务
  - 检查点后未提交的需要撤销，已提交的需要重做。

+ 示例
```
start transaction （或BEGIN,但在储存过程中不可用）//开启事务
select * from account where name = '张三' ;
update account set money = money - 100 where name = '张三' ;
update account set money = money + 100 where name = '李四';
commit ; //提交事务
rollback ; //回滚事务
```

### 事务并发执行
+ 不同的事务之间存在隔离性，变量为回话变量其他的事务无法访问。
+ 并发若与串行执行（先执行T1后执行T2或反之）结果不一致，则称并发执行存在问题。

#### **事务隔离级别**
+ 脏写：写入未提交数据，通过一级封锁协议解决。
+ 读取未提交数据read uncommited：脏读。
+ 读已提交数据read commited：不可重复读、幻读（**读取后其他事务插入记录或删除记录导致，幻多、幻少**）。
+ 可重复读repeatable read：并发读取仍可读到相同数据。
+ 串行化serializable：顺序低效执行，避免脏读、不可重复读、虚读。
+ **可通过SET {SELLION | GLOBAL} TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|serializable串行化]设置当前sellion或GLOBAL全局隔离级别**

#### 事务操作
- 回滚到标记点：rollback to 标记名（定义标记点：SAVEPOINT 标记点名、释放标记点：RELEASE SAVEPOINT 标记点名）
- rollkback：回滚到事务开始点。
- commit：提交事务，将事务中所有SQL语句的修改永久保存到数据库中。


### 数据库锁
+ 行锁、页锁、表锁，锁的颗粒度不同，锁的开销也不同。
#### 锁的类型

|锁类型|特点|作用|效果| 
|:--:|:--:|:--:|:--:|
|共享锁**s**|允许事务读取数据|防止其他事务修改数据|允许读取，不允许修改|
|排他锁**x**|允许事务修改数据|防止其他事务修改数据|允许读取和修改，不允许其他事务修改|
|意向锁**lx（ls），有意取得x锁**|允许事务读取数据|防止其他事务修改数据|允许读取，不允许修改|

+ 意向锁：用于用户多颗粒度并存的场景，标识在较高层面上，示意是否加锁，其子节点默认会被加锁。加行锁前，事务会自动获取它的表意向锁以避免遍历。（**提高并发，减少开销**）
+ 共享意向锁、排它意向锁、自动添加。

### **封锁协议**
+ 描述：并发带来数据不一致，需要数据库提供隔离机制。
+ 严重性：修改丢失>脏读>不可重复读>幻读

|名称|描述|备注|操作|
|:--:|:--:|:--:|:--:|  
|修改丢失（A视角）|A、B事务同时更新，B覆盖了A的更新| 特殊不可重复读|update|
|脏读|B事务读取A未提交的修改，A进行rollback，B事务两次读取的数据不一致|读取缓存中未提交的数据|读取缓存中未提交的数据|update|
|不可重复读|B事务读取了两次数据，读取过程中A事务改变了数据，B事务两次读出来的数据不一致|读取已提交的数据|update/delete|
|幻读|B事务读取了两次数据，读取过程中A事务改变了数据，B事务两次读出来的数据不一致|读取已提交的数据|insert|  
+ 协议

|级别|说明|备注|   
|:--:|:--:|:--:|
|一级封锁协议|事务修改时加X锁，直到事务结束|解决了修改丢失|
|二级封锁协议|事务读取时加S锁，直到读取结束|解决了脏读|
|三级封锁协议|事务读取时加S锁，直到事务结束|解决了不可重复读|
 
### 并发调度
+ 并发调度：通过并发调度来协调事务的执行顺序。
#### 串行调度
+ 串行调度：事务按顺序执行，一个事务执行完毕后，再执行下一个事务。
#### 可串行调度
+ 按不同顺序串行调度，结果可能不同，但是数据保持一致性。
#### 两段锁协议
+ 加意向锁后未解锁直接叫排他锁会导致死锁的产生
+ 两段锁协议：(**只能获得一次和释放一次锁**)
  - 加锁阶段：可获得任何类型的锁，但是不可释放锁
  - 解锁阶段：可释放锁，不可获得
+ 可串行化可充分不必要推出两段协议。 

### 数据字典

### 分布式数据库
+ 定义：分散储存，集中管理。
+ 集中型数据库

|条件|说明|
|:--:|:--:|
|分布式|数据分散在不同的节点上|
|逻辑相关性|数据在逻辑上具有关联特性|
|场地透明性|使用不需指明数据位置|
|场地自治性|单独节点可执行局部请求|

+ 分部型数据库

|条件|说明|
|:--:|:--:|
|数据集中控制性|全局管理员和局部管理员分层控制|
|数据独立性|不考虑数据库分散特性|
|数据冗余可控性|数据副本：节约传输开销；提高可用性；保证数据完整性；提高自治性能|
|场地自治性|局部数据库在逻辑上集成为整体；局部数据可以不参与到全局中|
|存取有效性|全局查询分散为等效子查询，全局优化和局部优化|



## 其他
+ 符号表管理
 - 符号表的作用是记录源程序中各种符号的必要信息，以辅助语义的正确性检查和代码生成，在编译过程中需要对符号表进行快速有效地查找、插入、修改和删除等操作。
+ 出错处理
 - 源程序中不可避免地会有一些错误，大致分为静态错误和动态错误。
  * 动态错误发生在程序运行时，如:变量取零时作除数、引用数组下标错误等。 
  * 静态错误是指编译阶段发现的程序错误，可分为语法错误和静态语义错误。① 语法错误:单词拼写错误、标点符号错、表达式中缺少操作数、括号不匹配等有关语言结构上的错误。
  * 静态语义错误:语义分析时发现的运算符和运算对象类型不合法等错误。
+ 直接引用和间接引用，值传递和地址传递。
+ 在Windows系统下,使用system命令执行cls命令即可清除屏幕。上述示例中,我们在MySQL命令行界面中输入system cls;,按下回车键后,屏幕将被清空。
+ 鸿蒙系统是操作系统，OpenGauss是华为数据库。
+ SQL实验
```
SELECT attendance_wage, merit_pay, overtime_wage
INTO (b) :attendance,:merit,:overtime&nbsp; 

```
# 参考资料
## 参考视频
+ 2021软考真题解析(https://www.bilibili.com/video/BV17q4y1S7xo?p=69&vd_source=be6b27ccf01617cb75baf08e9f91c7d7)
+ 2022软考真题解析(https://www.bilibili.com/video/BV1Aj41137Aa?vd_source=be6b27ccf01617cb75baf08e9f91c7d7)
+ 2023软考真题解析(https://www.bilibili.com/video/BV1vj421o7W1?vd_source=be6b27ccf01617cb75baf08e9f91c7d7)
+ 黑马程序员 MySQL数据库入门到精通(https://www.bilibili.com/video/BV1Kr4y1i7ru?p=34&vd_source=be6b27ccf01617cb75baf08e9f91c7d7)
## 参考书籍
+ 官方教程：数据库工程师教程。
+ MYSQL8从入门到精通
## 刷题网站
+ 51CTO题库(https://t.51cto.com/)